workflows:
  ios-workflow:
    name: iOS Build
    instance_type: mac_mini_m2
    max_build_duration: 120
    integrations:
      app_store_connect: iOS Kairo
    environment:
      ios_signing:
        distribution_type: app_store
        bundle_identifier: com.kairo
      vars:
        XCODE_WORKSPACE: "ios/App/App.xcworkspace"
        XCODE_SCHEME: "App"
        VITE_SUPABASE_URL: "https://codkpccwtffhoacwswso.supabase.co"
        VITE_SUPABASE_PUBLISHABLE_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNvZGtwY2N3dGZmaG9hY3dzd3NvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4NDEwNjIsImV4cCI6MjA4MTQxNzA2Mn0.X_FY1v9E0HLlHFoK6ZQMqPEXKRCxN9RaXj4IQi7VK9w"
        VITE_SUPABASE_PROJECT_ID: "codkpccwtffhoacwswso"
      node: v22
      xcode: latest
      cocoapods: default
    
    scripts:
      - name: Install dependencies
        script: npm install
      
      - name: Patch CallKit VoIP Plugin for Custom Ringtone and TTS
        script: |
          echo "=== Patching capacitor-plugin-callkit-voip for ringtone + TTS support ==="
          
          PLUGIN_FILE="node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift"
          
          if [ ! -f "$PLUGIN_FILE" ]; then
            echo "‚ùå Plugin file not found at $PLUGIN_FILE"
            exit 1
          fi
          
          echo "Creating patched CallKitVoipPlugin.swift with DEBUG EVENTS + FIXES..."
          
          cat > "$PLUGIN_FILE" << 'SWIFT_EOF'
          import Foundation
          import Capacitor
          import UIKit
          import CallKit
          import PushKit
          import AVFoundation

          @objc(CallKitVoipPlugin)
          public class CallKitVoipPlugin: CAPPlugin, CXProviderDelegate, PKPushRegistryDelegate {
              private var provider: CXProvider?
              private var callController = CXCallController()
              private var currentCallUUID: UUID?
              private var silencePlayer: AVAudioPlayer?
              private var currentEventData: [String: Any] = [:]  // Store event data for TTS
              
              @objc override public func load() {
                  let config = CXProviderConfiguration(localizedName: "Kairo")
                  config.supportsVideo = false
                  config.supportedHandleTypes = [.generic]
                  config.maximumCallGroups = 1
                  config.maximumCallsPerCallGroup = 1
                  config.ringtoneSound = "toqueios.caf"
                  
                  provider = CXProvider(configuration: config)
                  provider?.setDelegate(self, queue: nil)
                  
                  let voipRegistry = PKPushRegistry(queue: DispatchQueue.main)
                  voipRegistry.delegate = self
                  voipRegistry.desiredPushTypes = [.voIP]
              }
              
              // Start audio anchor - plays silence.caf in loop to keep call alive
              // Returns tuple with (found, started) for debugging
              private func startAudioAnchor() -> (found: Bool, started: Bool) {
                  var silenceFound = false
                  var silenceStarted = false
                  
                  do {
                      let session = AVAudioSession.sharedInstance()
                      try session.setCategory(.playback, mode: .default, options: [.mixWithOthers])
                      try session.setActive(true)
                      print("[CallKit] Audio session activated for anchor")
                      
                      // Debug: list bundle resources
                      var cafFiles: [String] = []
                      if let resourcePath = Bundle.main.resourcePath {
                          let files = try? FileManager.default.contentsOfDirectory(atPath: resourcePath)
                          cafFiles = files?.filter { $0.hasSuffix(".caf") } ?? []
                          print("[CallKit] CAF files in bundle: \(cafFiles)")
                      }
                      
                      // Play silence.caf in infinite loop to keep call anchored
                      if let url = Bundle.main.url(forResource: "silence", withExtension: "caf") {
                          print("[CallKit] Found silence.caf at: \(url.path)")
                          silenceFound = true
                          silencePlayer = try AVAudioPlayer(contentsOf: url)
                          silencePlayer?.numberOfLoops = -1  // Infinite loop
                          silencePlayer?.volume = 0.01  // Almost inaudible
                          silenceStarted = silencePlayer?.play() ?? false
                          print("[CallKit] Silence audio anchor started: \(silenceStarted)")
                      } else {
                          print("[CallKit] ‚ùå silence.caf NOT found in bundle!")
                          silenceFound = false
                      }
                  } catch {
                      print("[CallKit] Failed to start audio anchor: \(error)")
                  }
                  
                  return (silenceFound, silenceStarted)
              }
              
              // Stop audio anchor
              private func stopAudioAnchor() {
                  silencePlayer?.stop()
                  silencePlayer = nil
                  print("[CallKit] Silence audio anchor stopped")
              }
              
              // Configure audio session for TTS playback during call
              private func configureAudioSession() {
                  do {
                      let session = AVAudioSession.sharedInstance()
                      try session.setCategory(.playAndRecord, mode: .voiceChat, options: [.defaultToSpeaker, .allowBluetoothA2DP])
                      try session.setActive(true)
                      print("[CallKit] Audio session configured for TTS playback")
                  } catch {
                      print("[CallKit] Failed to configure audio session: \(error)")
                  }
              }
              
              // MARK: - PKPushRegistryDelegate
              
              public func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
                  let token = pushCredentials.token.map { String(format: "%02.2hhx", $0) }.joined()
                  print("[CallKit] VoIP token: \(token)")
                  notifyListeners("registration", data: ["value": token])
              }
              
              public func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {
                  print("[CallKit] ====== VOIP PUSH RECEIVED ======")
                  print("[CallKit] Full payload: \(payload.dictionaryPayload)")
                  
                  // Extract payload data for debugging
                  let payloadId = payload.dictionaryPayload["id"] as? String ?? "NIL"
                  let payloadName = payload.dictionaryPayload["name"] as? String ?? "NIL"
                  
                  // DEBUG EVENT 1: Push received - sends to JavaScript
                  notifyListeners("debug", data: [
                      "stage": "push_received",
                      "payload_id": payloadId,
                      "payload_name": payloadName,
                      "payload_full": String(describing: payload.dictionaryPayload)
                  ])
                  
                  // FIX CALL CURTA: Never fail just because ID is not a valid UUID
                  // Generate a new UUID if the provided one is invalid
                  let idString = payload.dictionaryPayload["id"] as? String ?? ""
                  let callUUID = UUID(uuidString: idString) ?? UUID()
                  print("[CallKit] Using UUID: \(callUUID.uuidString) (original id: '\(idString)')")
                  
                  // FIX UNKNOWN: Separate displayName and handleValue
                  // displayName = full name with emoji (for localizedCallerName display)
                  // handleValue = fixed "Kairo" (iOS CXHandle doesn't like emojis)
                  let rawName = payload.dictionaryPayload["name"] as? String ?? ""
                  let displayName = rawName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty 
                      ? "Lembrete Kairo" 
                      : rawName
                  let handleValue = "Kairo"  // Fixed handle - no emoji!
                  
                  print("[CallKit] displayName: '\(displayName)' | handleValue: '\(handleValue)'")
                  
                  // Store event data for TTS playback
                  currentEventData = [
                      "eventId": idString,
                      "eventTitle": rawName,
                      "eventEmoji": payload.dictionaryPayload["eventEmoji"] as? String ?? "üìÖ",
                      "eventTime": payload.dictionaryPayload["eventTime"] as? String ?? "",
                      "eventLocation": payload.dictionaryPayload["eventLocation"] as? String ?? "",
                      "name": displayName
                  ]
                  print("[CallKit] Stored event data: \(currentEventData)")
                  
                  currentCallUUID = callUUID
                  
                  // Start audio anchor BEFORE reporting the call
                  let anchorResult = startAudioAnchor()
                  
                  // DEBUG EVENT 2: Audio anchor status
                  notifyListeners("debug", data: [
                      "stage": "anchor_start",
                      "silence_found": anchorResult.found,
                      "silence_started": anchorResult.started
                  ])
                  
                  let update = CXCallUpdate()
                  update.remoteHandle = CXHandle(type: .generic, value: handleValue)  // FIX: Fixed "Kairo" without emoji
                  update.localizedCallerName = displayName  // FIX: Full name with emoji for display
                  update.hasVideo = false
                  update.supportsHolding = false
                  update.supportsGrouping = false
                  update.supportsUngrouping = false
                  update.supportsDTMF = false
                  
                  provider?.reportNewIncomingCall(with: callUUID, update: update) { error in
                      var errorMessage: String? = nil
                      
                      if let error = error {
                          print("[CallKit] Failed to report incoming call: \(error)")
                          errorMessage = error.localizedDescription
                          self.stopAudioAnchor()
                      } else {
                          print("[CallKit] ‚úÖ Incoming call reported successfully")
                      }
                      
                      // DEBUG EVENT 3: Call reported - final status
                      self.notifyListeners("debug", data: [
                          "stage": "call_reported",
                          "displayName": displayName,
                          "handleValue": handleValue,
                          "uuid": callUUID.uuidString,
                          "error": errorMessage ?? "none"
                      ])
                      
                      completion()
                  }
              }
              
              public func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {
                  print("[CallKit] VoIP token invalidated")
              }
              
              // MARK: - CXProviderDelegate
              
              public func providerDidReset(_ provider: CXProvider) {
                  print("[CallKit] Provider did reset")
                  stopAudioAnchor()
                  currentCallUUID = nil
              }
              
              public func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {
                  print("[CallKit] Call answered")
                  
                  // Stop silence anchor before configuring for TTS
                  stopAudioAnchor()
                  
                  // Configure audio session for TTS playback
                  configureAudioSession()
                  
                  // Notify JavaScript that call was answered with event data for TTS
                  // DO NOT end the call here - let JavaScript handle it after TTS
                  if let uuid = currentCallUUID {
                      var answeredData = currentEventData
                      answeredData["id"] = uuid.uuidString
                      answeredData["connectionId"] = uuid.uuidString
                      print("[CallKit] Sending callAnswered with data: \(answeredData)")
                      notifyListeners("callAnswered", data: answeredData)
                  }
                  
                  action.fulfill()
                  
                  // Notify that call has started (audio connected) with event data
                  var startedData = currentEventData
                  startedData["id"] = currentCallUUID?.uuidString ?? ""
                  startedData["connectionId"] = currentCallUUID?.uuidString ?? ""
                  print("[CallKit] Sending callStarted with data: \(startedData)")
                  notifyListeners("callStarted", data: startedData)
              }
              
              public func provider(_ provider: CXProvider, perform action: CXEndCallAction) {
                  print("[CallKit] Call ended")
                  
                  // Stop audio anchor
                  stopAudioAnchor()
                  
                  if let uuid = currentCallUUID {
                      notifyListeners("callEnded", data: [
                          "id": uuid.uuidString,
                          "connectionId": uuid.uuidString
                      ])
                  }
                  
                  currentCallUUID = nil
                  action.fulfill()
              }
              
              public func provider(_ provider: CXProvider, perform action: CXStartCallAction) {
                  action.fulfill()
              }
              
              public func provider(_ provider: CXProvider, perform action: CXSetHeldCallAction) {
                  action.fulfill()
              }
              
              public func provider(_ provider: CXProvider, perform action: CXSetMutedCallAction) {
                  action.fulfill()
              }
              
              // MARK: - TTS Audio Player
              private var ttsPlayer: AVAudioPlayer?
              
              // MARK: - Plugin Methods
              
              @objc func register(_ call: CAPPluginCall) {
                  // VoIP registration is automatic in load()
                  call.resolve()
              }
              
              @objc func playTTSAudio(_ call: CAPPluginCall) {
                  print("[CallKit] ====== PLAY TTS AUDIO ======")
                  
                  guard let base64Audio = call.getString("audio") else {
                      print("[CallKit] No audio data provided")
                      call.reject("No audio data")
                      return
                  }
                  
                  print("[CallKit] Received base64 audio, length: \(base64Audio.count)")
                  
                  guard let audioData = Data(base64Encoded: base64Audio) else {
                      print("[CallKit] Invalid base64 encoding")
                      call.reject("Invalid base64")
                      return
                  }
                  
                  print("[CallKit] Decoded audio data, size: \(audioData.count) bytes")
                  
                  do {
                      // Configure audio session for MAXIMUM volume TTS playback
                      let session = AVAudioSession.sharedInstance()
                      try session.setCategory(.playAndRecord, mode: .spokenAudio, options: [.defaultToSpeaker, .allowBluetoothA2DP, .duckOthers])
                      try session.setActive(true)
                      try session.overrideOutputAudioPort(.speaker)  // Force speaker at max volume
                      print("[CallKit] Audio session configured for HIGH VOLUME TTS playback")
                      
                      // Create player from data
                      ttsPlayer = try AVAudioPlayer(data: audioData)
                      ttsPlayer?.numberOfLoops = 5  // Repeat 5 times
                      ttsPlayer?.volume = 1.0
                      
                      let started = ttsPlayer?.play() ?? false
                      print("[CallKit] TTS playback started: \(started)")
                      
                      if started {
                          call.resolve(["playing": true])
                      } else {
                          call.reject("Failed to start playback")
                      }
                  } catch {
                      print("[CallKit] Failed to play TTS audio: \(error)")
                      call.reject("Failed to play: \(error.localizedDescription)")
                  }
              }
              
              @objc func stopTTSAudio(_ call: CAPPluginCall) {
                  print("[CallKit] Stopping TTS audio")
                  ttsPlayer?.stop()
                  ttsPlayer = nil
                  call.resolve()
              }
              
              @objc func endCall(_ call: CAPPluginCall) {
                  guard let uuid = currentCallUUID else {
                      call.reject("No active call")
                      return
                  }
                  
                  // Stop TTS when ending call
                  ttsPlayer?.stop()
                  ttsPlayer = nil
                  stopAudioAnchor()
                  
                  let endCallAction = CXEndCallAction(call: uuid)
                  let transaction = CXTransaction(action: endCallAction)
                  
                  callController.request(transaction) { error in
                      if let error = error {
                          print("[CallKit] Failed to end call: \(error)")
                          call.reject("Failed to end call: \(error.localizedDescription)")
                      } else {
                          print("[CallKit] Call ended successfully via endCall")
                          call.resolve()
                      }
                  }
              }
              
              // New method for JavaScript to end call after TTS playback
              @objc func endCallFromJS(_ call: CAPPluginCall) {
                  print("[CallKit] endCallFromJS called from JavaScript")
                  
                  guard let uuid = currentCallUUID else {
                      print("[CallKit] No active call to end")
                      call.reject("No active call")
                      return
                  }
                  
                  // Stop TTS when ending call
                  ttsPlayer?.stop()
                  ttsPlayer = nil
                  stopAudioAnchor()
                  
                  let endCallAction = CXEndCallAction(call: uuid)
                  let transaction = CXTransaction(action: endCallAction)
                  
                  callController.request(transaction) { error in
                      if let error = error {
                          print("[CallKit] Failed to end call from JS: \(error)")
                          call.reject("Failed to end call: \(error.localizedDescription)")
                      } else {
                          print("[CallKit] Call ended successfully from JavaScript")
                          call.resolve()
                      }
                  }
              }
          }
          SWIFT_EOF
          
          echo "=== Patching plugin.m to expose endCallFromJS ==="
          
          PLUGIN_M_FILE="node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m"
          
          cat > "$PLUGIN_M_FILE" << 'OBJC_EOF'
          #import <Foundation/Foundation.h>
          #import <Capacitor/Capacitor.h>

          CAP_PLUGIN(CallKitVoipPlugin, "CallKitVoip",
              CAP_PLUGIN_METHOD(register, CAPPluginReturnPromise);
              CAP_PLUGIN_METHOD(endCall, CAPPluginReturnPromise);
              CAP_PLUGIN_METHOD(endCallFromJS, CAPPluginReturnPromise);
              CAP_PLUGIN_METHOD(playTTSAudio, CAPPluginReturnPromise);
              CAP_PLUGIN_METHOD(stopTTSAudio, CAPPluginReturnPromise);
          )
          OBJC_EOF
          
          echo "‚úÖ CallKit VoIP plugin patched successfully"
          echo "   - DEBUG EVENTS: push_received, anchor_start, call_reported"
          echo "   - FIX UNKNOWN: localizedCallerName=displayName, remoteHandle=Kairo"
          echo "   - FIX CALL CURTA: UUID(uuidString:) ?? UUID() - never fails"
          echo "   - Custom ringtone: toqueios.caf"
          echo "   - endCallFromJS method exposed"
      
      - name: Install capacitor-assets
        script: npm install -g @capacitor/assets
      
      - name: Build web assets
        script: npm run build
      
      - name: Add and Sync Capacitor iOS
        script: |
          rm -rf ios
          export NODE_ENV=production
          npx cap add ios --packagemanager cocoapods
          npx cap sync ios
      
      - name: Generate Silence Audio File for CallKit Anchor
        script: |
          echo "=== Generating silence.caf for CallKit audio anchor ==="
          
          mkdir -p resources
          
          # Method 1: Try sox first (most reliable)
          if command -v sox &> /dev/null; then
            echo "Using sox to generate silence.caf..."
            sox -n -r 44100 -c 1 -b 16 resources/silence.caf trim 0.0 2.0
            echo "‚úÖ silence.caf created with sox"
          else
            echo "sox not found, using Python to create silence.caf..."
            # Method 2: Create with Python (always available on macOS)
            python3 << 'PYTHON_SCRIPT'
          import struct
          import os
          
          # CAF file format for 2 seconds of silence at 44100 Hz, 16-bit mono
          sample_rate = 44100
          duration = 2
          channels = 1
          bits_per_sample = 16
          num_samples = sample_rate * duration
          
          # CAF header
          caf_header = b'caff'  # File type
          caf_header += struct.pack('>H', 1)  # File version
          caf_header += struct.pack('>H', 0)  # Flags
          
          # Audio Description chunk
          desc_chunk = b'desc'
          desc_chunk += struct.pack('>Q', 32)  # Chunk size
          desc_chunk += struct.pack('>d', float(sample_rate))  # Sample rate
          desc_chunk += b'lpcm'  # Format ID (Linear PCM)
          desc_chunk += struct.pack('>I', 12)  # Format flags (little endian, signed integer)
          desc_chunk += struct.pack('>I', 2)  # Bytes per packet
          desc_chunk += struct.pack('>I', 1)  # Frames per packet
          desc_chunk += struct.pack('>I', channels)  # Channels per frame
          desc_chunk += struct.pack('>I', bits_per_sample)  # Bits per channel
          
          # Data chunk
          audio_data = b'\x00' * (num_samples * channels * (bits_per_sample // 8))
          data_chunk = b'data'
          data_chunk += struct.pack('>Q', len(audio_data) + 4)  # Chunk size
          data_chunk += struct.pack('>I', 0)  # Edit count
          data_chunk += audio_data
          
          # Write file
          os.makedirs('resources', exist_ok=True)
          with open('resources/silence.caf', 'wb') as f:
              f.write(caf_header + desc_chunk + data_chunk)
          
          print("silence.caf created with Python")
          PYTHON_SCRIPT
            echo "‚úÖ silence.caf created with Python"
          fi
          
          if [ -f "resources/silence.caf" ]; then
            echo "‚úÖ resources/silence.caf verified successfully"
            ls -la resources/silence.caf
          else
            echo "‚ùå Failed to create silence.caf"
            exit 1
          fi
      
      - name: Copy Ringtone and Silence to iOS Bundle
        script: |
          echo "=== Copying audio files to iOS bundle ==="
          
          # Copy toqueios.caf (ringtone)
          if [ -f "resources/toqueios.caf" ]; then
            cp resources/toqueios.caf ios/App/App/toqueios.caf
            echo "‚úÖ toqueios.caf copied to ios/App/App/"
          else
            echo "‚ùå resources/toqueios.caf not found!"
            exit 1
          fi
          
          # Copy silence.caf (audio anchor)
          if [ -f "resources/silence.caf" ]; then
            cp resources/silence.caf ios/App/App/silence.caf
            echo "‚úÖ silence.caf copied to ios/App/App/"
          else
            echo "‚ùå resources/silence.caf not found!"
            exit 1
          fi
          
          echo "=== Adding audio files to Xcode project ==="
          
          ruby <<'RUBY'
          require 'xcodeproj'
          
          begin
            project_path = 'ios/App/App.xcodeproj'
            puts "Opening project: #{project_path}"
            project = Xcodeproj::Project.open(project_path)
            
            target = project.targets.first
            puts "Target: #{target.name}"
            
            app_group = project.main_group['App']
            
            # Get resources build phase
            resources_phase = target.resources_build_phase
            
            # Add toqueios.caf to Resources (not Compile Sources)
            existing_ringtone = app_group.files.find { |f| f.path == 'toqueios.caf' }
            if existing_ringtone.nil?
              puts "Adding toqueios.caf to project as resource..."
              file_ref = app_group.new_file('toqueios.caf')
              file_ref.last_known_file_type = 'audio.caf'
              build_file = resources_phase.add_file_reference(file_ref)
              puts "‚úÖ toqueios.caf added to Resources build phase"
            else
              puts "‚ÑπÔ∏è toqueios.caf already exists in project"
            end
            
            # Add silence.caf to Resources (not Compile Sources)
            existing_silence = app_group.files.find { |f| f.path == 'silence.caf' }
            if existing_silence.nil?
              puts "Adding silence.caf to project as resource..."
              file_ref = app_group.new_file('silence.caf')
              file_ref.last_known_file_type = 'audio.caf'
              build_file = resources_phase.add_file_reference(file_ref)
              puts "‚úÖ silence.caf added to Resources build phase"
            else
              puts "‚ÑπÔ∏è silence.caf already exists in project"
            end
            
            project.save
            puts "‚úÖ Project saved successfully"
            
          rescue => e
            puts "‚ùå Error: #{e.message}"
            puts e.backtrace.first(5).join("\n")
            exit 1
          end
          RUBY
          
          echo "‚úÖ Audio files configuration complete"
      
      - name: Add Camera and Photo Library Permissions to Info.plist
        script: |
          # Force dark mode and set background color in Info.plist
          /usr/libexec/PlistBuddy -c "Add :UIUserInterfaceStyle string 'Dark'" ios/App/App/Info.plist || /usr/libexec/PlistBuddy -c "Set :UIUserInterfaceStyle 'Dark'" ios/App/App/Info.plist
          echo "‚úÖ UIUserInterfaceStyle set to Dark"
          
          /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'This app needs camera access to capture images'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'This app needs photo library access to select images'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'This app needs permission to save photos'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'This app needs microphone access for audio recording'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationWhenInUseUsageDescription string 'Kairo needs your location to provide location-based reminders and alerts'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationAlwaysAndWhenInUseUsageDescription string 'Kairo needs your location to provide location-based reminders and alerts even when the app is in the background'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes array" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:0 string 'voip'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:1 string 'remote-notification'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:2 string 'fetch'" ios/App/App/Info.plist || true
          echo "All permissions and background modes added to Info.plist"
      
      - name: Copy and Add GoogleService-Info.plist to Xcode Project
        script: |
          cp GoogleService-Info.plist ios/App/App/GoogleService-Info.plist
          
          ruby <<EOF
          require 'xcodeproj'
          project_path = 'ios/App/App.xcodeproj'
          project = Xcodeproj::Project.open(project_path)
          
          target = project.targets.first
          
          file_ref = project.main_group['App'].new_file('GoogleService-Info.plist')
          target.add_file_references([file_ref])
          
          project.save
          EOF
          echo "GoogleService-Info.plist added to Xcode project and target"
      
      - name: Add Firebase and CallKit VoIP to Podfile
        script: |
          PODFILE_PATH="ios/App/Podfile"
          
          echo "=== Creating Podfile with Firebase + CallKit VoIP ==="
          cat > "$PODFILE_PATH" << 'PODFILE_CONTENT'
          require_relative '../../node_modules/@capacitor/ios/scripts/pods_helpers'

          platform :ios, '13.0'
          use_frameworks!

          install! 'cocoapods', :disable_input_output_paths => true

          def capacitor_pods
            pod 'Capacitor', :path => '../../node_modules/@capacitor/ios'
            pod 'CapacitorCordova', :path => '../../node_modules/@capacitor/ios'
            pod 'CapacitorGeolocation', :path => '../../node_modules/@capacitor/geolocation'
            pod 'CapacitorHaptics', :path => '../../node_modules/@capacitor/haptics'
            pod 'CapacitorLocalNotifications', :path => '../../node_modules/@capacitor/local-notifications'
            pod 'CapacitorPushNotifications', :path => '../../node_modules/@capacitor/push-notifications'
            pod 'CapacitorPluginCallkitVoip', :path => '../../node_modules/capacitor-plugin-callkit-voip'
          end

          target 'App' do
            capacitor_pods
            pod 'Firebase/Messaging'
          end

          post_install do |installer|
            assertDeploymentTarget(installer)
          end
          PODFILE_CONTENT
          echo "=== Podfile created with CallKit VoIP plugin ==="
          cat "$PODFILE_PATH"
      
      - name: Configure AppDelegate for Firebase Messaging (Plugin handles VoIP)
        script: |
          cat > ios/App/App/AppDelegate.swift << 'EOF'
          import UIKit
          import Capacitor
          import Firebase
          import FirebaseMessaging
          import UserNotifications

          @UIApplicationMain
          class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate, MessagingDelegate {

              var window: UIWindow?

              func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
                  // üî• CRITICAL: Set dark background color FIRST to prevent white flash
                  self.window?.backgroundColor = UIColor(red: 10.0/255.0, green: 22.0/255.0, blue: 40.0/255.0, alpha: 1.0)
                  
                  FirebaseApp.configure()
                  
                  UNUserNotificationCenter.current().delegate = self
                  Messaging.messaging().delegate = self
                  
                  let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]
                  UNUserNotificationCenter.current().requestAuthorization(options: authOptions) { _, _ in }
                  application.registerForRemoteNotifications()
                  
                  // VoIP/CallKit is handled automatically by capacitor-plugin-callkit-voip
                  // Do NOT setup PKPushRegistry or CXProvider here - the plugin does it
                  
                  return true
              }

              func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
                  Messaging.messaging().apnsToken = deviceToken
                  NotificationCenter.default.post(name: .capacitorDidRegisterForRemoteNotifications, object: deviceToken)
              }

              func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
                  NotificationCenter.default.post(name: .capacitorDidFailToRegisterForRemoteNotifications, object: error)
              }

              func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
                  completionHandler([.banner, .badge, .sound])
              }

              func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
                  NotificationCenter.default.post(name: Notification.Name("pushNotificationReceived"), object: response.notification.request.content.userInfo)
                  completionHandler()
              }

              func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {
                  if let token = fcmToken {
                      NotificationCenter.default.post(name: Notification.Name("FCMToken"), object: nil, userInfo: ["token": token])
                  }
              }

              func applicationWillResignActive(_ application: UIApplication) {}
              func applicationDidEnterBackground(_ application: UIApplication) {}
              func applicationWillEnterForeground(_ application: UIApplication) {}
              func applicationDidBecomeActive(_ application: UIApplication) {}
              func applicationWillTerminate(_ application: UIApplication) {}
              func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
                  return ApplicationDelegateProxy.shared.application(app, open: url, options: options)
              }
              func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
                  return ApplicationDelegateProxy.shared.application(application, continue: userActivity, restorationHandler: restorationHandler)
              }
          }
          EOF
      
      - name: Add Push Notification Entitlements
        script: |
          echo "=== Creating App.entitlements file ==="
          
          # Create entitlements file (only aps-environment, VoIP is inferred via Background Mode)
          cat > ios/App/App/App.entitlements << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>aps-environment</key>
              <string>production</string>
          </dict>
          </plist>
          EOF
          
          echo "=== App.entitlements file created ==="
          cat ios/App/App/App.entitlements
          
          echo "=== Linking entitlements to Xcode project ==="
          
          # Link entitlements to Xcode target with error handling
          ruby <<'RUBY'
          require 'xcodeproj'
          
          begin
            project_path = 'ios/App/App.xcodeproj'
            puts "Opening project: #{project_path}"
            project = Xcodeproj::Project.open(project_path)
            
            target = project.targets.first
            puts "Target: #{target.name}"
            
            app_group = project.main_group['App']
            entitlements_path = 'App/App.entitlements'
            
            # Check if entitlements file already exists in project
            existing_file = app_group.files.find { |f| f.path == 'App.entitlements' }
            
            if existing_file.nil?
              puts "Adding App.entitlements to project..."
              file_ref = app_group.new_file('App.entitlements')
              puts "‚úÖ App.entitlements added to project"
            else
              puts "‚ÑπÔ∏è App.entitlements already exists in project, skipping add"
            end
            
            # Set CODE_SIGN_ENTITLEMENTS build setting for all configurations
            target.build_configurations.each do |config|
              config.build_settings['CODE_SIGN_ENTITLEMENTS'] = entitlements_path
              puts "Set CODE_SIGN_ENTITLEMENTS for #{config.name}"
            end
            
            project.save
            puts "‚úÖ Project saved successfully"
            puts "‚úÖ App.entitlements linked to target with CODE_SIGN_ENTITLEMENTS"
            
          rescue => e
            puts "‚ùå Error: #{e.message}"
            puts e.backtrace.first(5).join("\n")
            exit 1
          end
          RUBY
          
          echo "=== Entitlements configuration complete ==="
      
      - name: Set iOS version
        script: |
          cd ios/App
          agvtool new-version -all $BUILD_NUMBER
          agvtool new-marketing-version 1.0.1
      
      - name: Generate App Icons and Splash Screens
        script: npx capacitor-assets generate --ios
      
      # ==============================================================
      # IMPORTANTE: Os steps abaixo SOBRESCREVEM o LaunchScreen padr√£o
      # que foi gerado pelo capacitor-assets generate acima.
      # Isso garante que nosso splash customizado (polvo) seja usado.
      # ==============================================================
      
      - name: Configure LaunchScreen to Eliminate White Flash (AFTER capacitor-assets)
        script: |
          echo "=== Configuring LaunchScreen.storyboard to eliminate white flash ==="
          echo "=== This runs AFTER capacitor-assets generate to OVERRIDE defaults ==="
          
          LAUNCHSCREEN_PATH="ios/App/App/Base.lproj/LaunchScreen.storyboard"
          
          if [ ! -f "$LAUNCHSCREEN_PATH" ]; then
            echo "‚ùå LaunchScreen.storyboard not found at $LAUNCHSCREEN_PATH"
            ls -la ios/App/App/
            exit 1
          fi
          
          echo "Original LaunchScreen.storyboard (from capacitor-assets):"
          cat "$LAUNCHSCREEN_PATH"
          
          # Create new LaunchScreen.storyboard with dark background (#0a1628)
          # RGB values: R=10/255=0.039, G=22/255=0.086, B=40/255=0.157
          printf '%s\n' '<?xml version="1.0" encoding="UTF-8"?>' \
            '<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="21701" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">' \
            '    <device id="retina6_12" orientation="portrait" appearance="dark"/>' \
            '    <dependencies>' \
            '        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="21679"/>' \
            '        <capability name="Safe area layout guides" minToolsVersion="9.0"/>' \
            '        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>' \
            '    </dependencies>' \
            '    <scenes>' \
            '        <scene sceneID="EHf-IW-A2E">' \
            '            <objects>' \
            '                <viewController id="01J-lp-oVM" sceneMemberID="viewController">' \
            '                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">' \
            '                        <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>' \
            '                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>' \
            '                        <subviews>' \
            '                            <imageView clipsSubviews="YES" userInteractionEnabled="NO" contentMode="scaleAspectFill" horizontalHuggingPriority="251" verticalHuggingPriority="251" image="Splash" translatesAutoresizingMaskIntoConstraints="NO" id="splash-image">' \
            '                                <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>' \
            '                            </imageView>' \
            '                        </subviews>' \
            '                        <viewLayoutGuide key="safeArea" id="Bcu-3y-fUS"/>' \
            '                        <color key="backgroundColor" red="0.039215686274509803" green="0.086274509803921567" blue="0.156862745098039" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>' \
            '                        <constraints>' \
            '                            <constraint firstItem="splash-image" firstAttribute="top" secondItem="Ze5-6b-2t3" secondAttribute="top" id="top-constraint"/>' \
            '                            <constraint firstItem="splash-image" firstAttribute="leading" secondItem="Ze5-6b-2t3" secondAttribute="leading" id="leading-constraint"/>' \
            '                            <constraint firstItem="splash-image" firstAttribute="trailing" secondItem="Ze5-6b-2t3" secondAttribute="trailing" id="trailing-constraint"/>' \
            '                            <constraint firstItem="splash-image" firstAttribute="bottom" secondItem="Ze5-6b-2t3" secondAttribute="bottom" id="bottom-constraint"/>' \
            '                        </constraints>' \
            '                    </view>' \
            '                </viewController>' \
            '                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>' \
            '            </objects>' \
            '            <point key="canvasLocation" x="53" y="375"/>' \
            '        </scene>' \
            '    </scenes>' \
            '    <resources>' \
            '        <image name="Splash" width="2732" height="2732"/>' \
            '    </resources>' \
            '</document>' > "$LAUNCHSCREEN_PATH"
          
          echo ""
          echo "‚úÖ LaunchScreen.storyboard OVERWRITTEN with dark background (#0a1628) + Splash image"
          echo ""
          echo "New LaunchScreen.storyboard:"
          cat "$LAUNCHSCREEN_PATH"
      
      - name: Add Custom Splash Image to iOS Assets (AFTER capacitor-assets)
        script: |
          echo "=== Adding Custom Splash image to iOS Assets.xcassets ==="
          echo "=== This OVERRIDES the default splash from capacitor-assets ==="
          echo "DEBUG: Current directory: $(pwd)"
          echo "DEBUG: Listing src/assets:"
          ls -la src/assets/ || echo "src/assets not found"
          echo "DEBUG: Listing resources:"
          ls -la resources/ || echo "resources not found"
          
          ASSETS_PATH="ios/App/App/Assets.xcassets"
          SPLASH_IMAGESET="$ASSETS_PATH/Splash.imageset"
          
          echo "DEBUG: ASSETS_PATH=$ASSETS_PATH"
          echo "DEBUG: SPLASH_IMAGESET=$SPLASH_IMAGESET"
          
          # Remove existing Splash.imageset (from capacitor-assets) and recreate
          rm -rf "$SPLASH_IMAGESET"
          mkdir -p "$SPLASH_IMAGESET"
          echo "DEBUG: Created fresh $SPLASH_IMAGESET"
          
          # Copy splash image (use the dark version since our background is dark)
          if [ -f "src/assets/horah-splash-dark.png" ]; then
            cp src/assets/horah-splash-dark.png "$SPLASH_IMAGESET/splash.png"
            echo "‚úÖ Copied horah-splash-dark.png to Splash.imageset (polvo!)"
            echo "DEBUG: File size:"
            ls -la "$SPLASH_IMAGESET/splash.png"
          elif [ -f "resources/splash.png" ]; then
            cp resources/splash.png "$SPLASH_IMAGESET/splash.png"
            echo "‚úÖ Copied resources/splash.png to Splash.imageset"
            echo "DEBUG: File size:"
            ls -la "$SPLASH_IMAGESET/splash.png"
          else
            echo "‚ùå ERROR: No splash image found!"
            echo "DEBUG: Checking all available images:"
            find . -name "*.png" -type f | head -20
          fi
          
          # Create Contents.json for the imageset
          printf '%s\n' '{' \
            '  "images" : [' \
            '    {' \
            '      "filename" : "splash.png",' \
            '      "idiom" : "universal",' \
            '      "scale" : "1x"' \
            '    },' \
            '    {' \
            '      "filename" : "splash.png",' \
            '      "idiom" : "universal",' \
            '      "scale" : "2x"' \
            '    },' \
            '    {' \
            '      "filename" : "splash.png",' \
            '      "idiom" : "universal",' \
            '      "scale" : "3x"' \
            '    }' \
            '  ],' \
            '  "info" : {' \
            '    "author" : "xcode",' \
            '    "version" : 1' \
            '  }' \
            '}' > "$SPLASH_IMAGESET/Contents.json"
          
          echo "‚úÖ Custom Splash.imageset configured in Assets.xcassets"
          ls -la "$SPLASH_IMAGESET"
      
      - name: Register Splash Image in Xcode Project
        script: |
          echo "=== Registering Splash.imageset in Xcode project ==="
          
          ruby <<RUBY
          require 'xcodeproj'
          
          project_path = 'ios/App/App.xcodeproj'
          project = Xcodeproj::Project.open(project_path)
          
          # Find the Assets.xcassets group
          app_group = project.main_group['App']
          assets_ref = app_group.files.find { |f| f.path == 'Assets.xcassets' }
          
          if assets_ref
            puts "‚úÖ Assets.xcassets is already referenced in project"
          else
            puts "‚ö†Ô∏è Adding Assets.xcassets reference to project"
            assets_ref = app_group.new_reference('Assets.xcassets')
          end
          
          project.save
          puts "‚úÖ Xcode project saved with custom splash"
          RUBY
          
          echo "‚úÖ Custom splash image registered in Xcode project"
      
      - name: Install CocoaPods
        script: |
          rm -rf ios/App/CapApp-SPM
          cd ios/App && pod install
      
      - name: Verify Swift Patch Applied
        script: |
          echo "=== VERIFYING SWIFT PATCH IN NODE_MODULES ==="
          SWIFT_FILE="node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift"
          
          if [ ! -f "$SWIFT_FILE" ]; then
            echo "‚ùå Swift file not found at $SWIFT_FILE"
            echo "Listing node_modules plugin directory..."
            ls -la node_modules/capacitor-plugin-callkit-voip/ios/Plugin/ || echo "Plugin directory not found"
            exit 1
          fi
          
          echo "--- First 60 lines of patched Swift file ---"
          head -60 "$SWIFT_FILE"
          
          echo ""
          echo "--- Searching for CRITICAL MARKERS ---"
          echo ""
          
          # Check for debug events
          if grep -n 'notifyListeners.*debug' "$SWIFT_FILE"; then
            echo "‚úÖ DEBUG LISTENER FOUND"
          else
            echo "‚ùå DEBUG LISTENER NOT FOUND - PATCH MAY NOT BE APPLIED!"
          fi
          
          # Check for silence.caf reference
          if grep -n 'silence.caf' "$SWIFT_FILE"; then
            echo "‚úÖ SILENCE.CAF REFERENCE FOUND"
          else
            echo "‚ùå SILENCE.CAF REFERENCE NOT FOUND"
          fi
          
          # Check for localizedCallerName (the fix for Unknown)
          if grep -n 'localizedCallerName = displayName' "$SWIFT_FILE"; then
            echo "‚úÖ LOCALIZED CALLER NAME FIX FOUND"
          else
            echo "‚ùå LOCALIZED CALLER NAME FIX NOT FOUND"
          fi
          
          # Check for handleValue = "Kairo" (the fix for emoji in handle)
          if grep -n 'handleValue = "Kairo"' "$SWIFT_FILE"; then
            echo "‚úÖ HANDLE VALUE FIX FOUND (no emoji)"
          else
            echo "‚ùå HANDLE VALUE FIX NOT FOUND"
          fi
          
          # Check for UUID fallback (the fix for call curta)
          if grep -n 'UUID(uuidString: idString) ?? UUID()' "$SWIFT_FILE"; then
            echo "‚úÖ UUID FALLBACK FIX FOUND (no more .failed)"
          else
            echo "‚ùå UUID FALLBACK FIX NOT FOUND"
          fi
          
          echo ""
          echo "=== END VERIFICATION ==="
      
      - name: Initialize keychain
        script: keychain initialize
      
      - name: Add certificates to keychain
        script: keychain add-certificates
      
      - name: Set up code signing settings on Xcode project
        script: xcode-project use-profiles
      
      - name: Build IPA
        script: |
          xcode-project build-ipa \
            --workspace "$XCODE_WORKSPACE" \
            --scheme "$XCODE_SCHEME"
    
    artifacts:
      - build/ios/ipa/*.ipa
      - /tmp/xcodebuild_logs/*.log
    
    publishing:
      app_store_connect:
        auth: integration
        submit_to_testflight: true
