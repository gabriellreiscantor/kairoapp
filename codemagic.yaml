workflows:
  ios-workflow:
    name: iOS Build
    instance_type: mac_mini_m2
    max_build_duration: 120
    integrations:
      app_store_connect: iOS Kairo
    environment:
      ios_signing:
        distribution_type: app_store
        bundle_identifier: com.kairo
      vars:
        XCODE_WORKSPACE: "ios/App/App.xcworkspace"
        XCODE_SCHEME: "App"
        VITE_SUPABASE_URL: "https://codkpccwtffhoacwswso.supabase.co"
        VITE_SUPABASE_PUBLISHABLE_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNvZGtwY2N3dGZmaG9hY3dzd3NvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4NDEwNjIsImV4cCI6MjA4MTQxNzA2Mn0.X_FY1v9E0HLlHFoK6ZQMqPEXKRCxN9RaXj4IQi7VK9w"
        VITE_SUPABASE_PROJECT_ID: "codkpccwtffhoacwswso"
      node: v22
      xcode: latest
      cocoapods: default
    
    scripts:
      - name: Install dependencies
        script: npm install
      
      - name: Install capacitor-assets
        script: npm install -g @capacitor/assets
      
      - name: Build web assets
        script: npm run build
      
      - name: Add and Sync Capacitor iOS
        script: |
          rm -rf ios
          export NODE_ENV=production
          npx cap add ios --packagemanager cocoapods
          npx cap sync ios
      
      - name: Add Camera and Photo Library Permissions to Info.plist
        script: |
          /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'This app needs camera access to capture images'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'This app needs photo library access to select images'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'This app needs permission to save photos'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'This app needs microphone access for audio recording'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationWhenInUseUsageDescription string 'Kairo needs your location to provide location-based reminders and alerts'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationAlwaysAndWhenInUseUsageDescription string 'Kairo needs your location to provide location-based reminders and alerts even when the app is in the background'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes array" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:0 string 'voip'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:1 string 'remote-notification'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:2 string 'fetch'" ios/App/App/Info.plist || true
          echo "All permissions and background modes added to Info.plist"
      
      - name: Copy and Add GoogleService-Info.plist to Xcode Project
        script: |
          cp GoogleService-Info.plist ios/App/App/GoogleService-Info.plist
          
          ruby <<EOF
          require 'xcodeproj'
          project_path = 'ios/App/App.xcodeproj'
          project = Xcodeproj::Project.open(project_path)
          
          target = project.targets.first
          
          file_ref = project.main_group['App'].new_file('GoogleService-Info.plist')
          target.add_file_references([file_ref])
          
          project.save
          EOF
          echo "GoogleService-Info.plist added to Xcode project and target"
      
      - name: Add Firebase to Podfile
        script: |
          PODFILE_PATH="ios/App/Podfile"
          
          if [ ! -f "$PODFILE_PATH" ]; then
            echo "=== Podfile not found, creating with Firebase ==="
            cat > "$PODFILE_PATH" << 'PODFILE_CONTENT'
          require_relative '../../node_modules/@capacitor/ios/scripts/pods_helpers'

          platform :ios, '13.0'
          use_frameworks!

          install! 'cocoapods', :disable_input_output_paths => true

          def capacitor_pods
            pod 'Capacitor', :path => '../../node_modules/@capacitor/ios'
            pod 'CapacitorCordova', :path => '../../node_modules/@capacitor/ios'
            pod 'CapacitorGeolocation', :path => '../../node_modules/@capacitor/geolocation'
            pod 'CapacitorHaptics', :path => '../../node_modules/@capacitor/haptics'
            pod 'CapacitorLocalNotifications', :path => '../../node_modules/@capacitor/local-notifications'
            pod 'CapacitorPushNotifications', :path => '../../node_modules/@capacitor/push-notifications'
          end

          target 'App' do
            capacitor_pods
            pod 'Firebase/Messaging'
          end

          post_install do |installer|
            assertDeploymentTarget(installer)
          end
          PODFILE_CONTENT
            echo "=== Podfile created ==="
            cat "$PODFILE_PATH"
          else
            echo "=== Podfile exists, checking Firebase ==="
            if ! grep -q "Firebase/Messaging" "$PODFILE_PATH"; then
              sed -i '' '/capacitor_pods/a\
            pod '"'"'Firebase/Messaging'"'"'
          ' "$PODFILE_PATH"
              echo "Firebase added"
            else
              echo "Firebase already present"
            fi
            cat "$PODFILE_PATH"
          fi
      
      - name: Configure AppDelegate for Firebase Messaging and VoIP CallKit
        script: |
          cat > ios/App/App/AppDelegate.swift << 'EOF'
          import UIKit
          import Capacitor
          import Firebase
          import FirebaseMessaging
          import UserNotifications
          import PushKit
          import CallKit

          @UIApplicationMain
          class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate, MessagingDelegate, PKPushRegistryDelegate {

              var window: UIWindow?
              var voipRegistry: PKPushRegistry?
              var callKitProvider: CXProvider?
              var callKitController: CXCallController?
              var pendingCallData: [String: Any]?

              func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
                  FirebaseApp.configure()
                  
                  UNUserNotificationCenter.current().delegate = self
                  Messaging.messaging().delegate = self
                  
                  let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]
                  UNUserNotificationCenter.current().requestAuthorization(options: authOptions) { _, _ in }
                  application.registerForRemoteNotifications()
                  
                  // Setup VoIP Push Registry
                  setupVoIPRegistry()
                  
                  // Setup CallKit
                  setupCallKit()
                  
                  return true
              }
              
              // MARK: - VoIP Push Setup
              private func setupVoIPRegistry() {
                  voipRegistry = PKPushRegistry(queue: DispatchQueue.main)
                  voipRegistry?.delegate = self
                  voipRegistry?.desiredPushTypes = [.voIP]
              }
              
              // MARK: - CallKit Setup
              private func setupCallKit() {
                  let config = CXProviderConfiguration()
                  config.supportsVideo = false
                  config.maximumCallsPerCallGroup = 1
                  config.supportedHandleTypes = [.generic]
                  config.ringtoneSound = nil  // Use system ringtone
                  
                  if let iconImage = UIImage(named: "AppIcon") {
                      config.iconTemplateImageData = iconImage.pngData()
                  }
                  
                  callKitProvider = CXProvider(configuration: config)
                  callKitProvider?.setDelegate(self, queue: DispatchQueue.main)
                  callKitController = CXCallController()
              }
              
              // MARK: - PKPushRegistryDelegate
              func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
                  if type == .voIP {
                      let token = pushCredentials.token.map { String(format: "%02x", $0) }.joined()
                      print("[VoIP] Token received: \(token.prefix(20))...")
                      
                      // Post notification to JS layer
                      NotificationCenter.default.post(
                          name: Notification.Name("VoIPTokenReceived"),
                          object: nil,
                          userInfo: ["token": token]
                      )
                      
                  }
              }
              
              func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {
                  guard type == .voIP else {
                      completion()
                      return
                  }
                  
                  print("[VoIP] Received VoIP push: \(payload.dictionaryPayload)")
                  
                  let callerName = payload.dictionaryPayload["callerName"] as? String ?? "Kairo"
                  let uuid = UUID()
                  let eventId = payload.dictionaryPayload["eventId"] as? String ?? uuid.uuidString
                  
                  // Store payload data for later
                  pendingCallData = payload.dictionaryPayload as? [String: Any]
                  
                  // Report incoming call to CallKit
                  reportIncomingCall(uuid: uuid, callerName: callerName, eventId: eventId)
                  
                  completion()
              }
              
              private func reportIncomingCall(uuid: UUID, callerName: String, eventId: String) {
                  let update = CXCallUpdate()
                  update.remoteHandle = CXHandle(type: .generic, value: eventId)
                  update.localizedCallerName = callerName
                  update.hasVideo = false
                  update.supportsGrouping = false
                  update.supportsUngrouping = false
                  update.supportsHolding = false
                  update.supportsDTMF = false
                  
                  callKitProvider?.reportNewIncomingCall(with: uuid, update: update) { error in
                      if let error = error {
                          print("[CallKit] Error reporting incoming call: \(error.localizedDescription)")
                      } else {
                          print("[CallKit] Incoming call reported successfully")
                          
                          // Notify JS layer about incoming call
                          NotificationCenter.default.post(
                              name: Notification.Name("CallKitCallStarted"),
                              object: nil,
                              userInfo: self.pendingCallData
                          )
                      }
                  }
              }

              func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
                  Messaging.messaging().apnsToken = deviceToken
                  NotificationCenter.default.post(name: .capacitorDidRegisterForRemoteNotifications, object: deviceToken)
              }

              func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
                  NotificationCenter.default.post(name: .capacitorDidFailToRegisterForRemoteNotifications, object: error)
              }

              func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
                  completionHandler([.banner, .badge, .sound])
              }

              func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
                  NotificationCenter.default.post(name: Notification.Name("pushNotificationReceived"), object: response.notification.request.content.userInfo)
                  completionHandler()
              }

              func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {
                  if let token = fcmToken {
                      NotificationCenter.default.post(name: Notification.Name("FCMToken"), object: nil, userInfo: ["token": token])
                  }
              }

              func applicationWillResignActive(_ application: UIApplication) {}
              func applicationDidEnterBackground(_ application: UIApplication) {}
              func applicationWillEnterForeground(_ application: UIApplication) {}
              func applicationDidBecomeActive(_ application: UIApplication) {}
              func applicationWillTerminate(_ application: UIApplication) {}
              func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
                  return ApplicationDelegateProxy.shared.application(app, open: url, options: options)
              }
              func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
                  return ApplicationDelegateProxy.shared.application(application, continue: userActivity, restorationHandler: restorationHandler)
              }
          }

          // MARK: - CXProviderDelegate
          extension AppDelegate: CXProviderDelegate {
              func providerDidReset(_ provider: CXProvider) {
                  print("[CallKit] Provider did reset")
              }
              
              func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {
                  print("[CallKit] Call answered")
                  
                  // Notify JS layer
                  NotificationCenter.default.post(
                      name: Notification.Name("CallKitCallAnswered"),
                      object: nil,
                      userInfo: pendingCallData
                  )
                  
                  action.fulfill()
              }
              
              func provider(_ provider: CXProvider, perform action: CXEndCallAction) {
                  print("[CallKit] Call ended")
                  
                  // Notify JS layer
                  NotificationCenter.default.post(
                      name: Notification.Name("CallKitCallEnded"),
                      object: nil,
                      userInfo: pendingCallData
                  )
                  
                  pendingCallData = nil
                  action.fulfill()
              }
              
              func provider(_ provider: CXProvider, perform action: CXStartCallAction) {
                  action.fulfill()
              }
              
              func provider(_ provider: CXProvider, perform action: CXSetHeldCallAction) {
                  action.fulfill()
              }
              
              func provider(_ provider: CXProvider, perform action: CXSetMutedCallAction) {
                  action.fulfill()
              }
          }
          EOF
      
      - name: Add Push Notification and VoIP Entitlements
        script: |
          cat > ios/App/App/App.entitlements << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>aps-environment</key>
              <string>production</string>
              <key>com.apple.developer.pushkit.voip</key>
              <true/>
          </dict>
          </plist>
          EOF
      
      - name: Set iOS version
        script: |
          cd ios/App
          agvtool new-version -all $(($(date +%s) / 60))
          agvtool new-marketing-version 1.0.1
      
      - name: Generate App Icons and Splash Screens
        script: npx capacitor-assets generate --ios
      
      - name: Install CocoaPods
        script: |
          rm -rf ios/App/CapApp-SPM
          cd ios/App && pod install
      
      - name: Initialize keychain
        script: keychain initialize
      
      - name: Add certificates to keychain
        script: keychain add-certificates
      
      - name: Set up code signing settings on Xcode project
        script: xcode-project use-profiles
      
      - name: Build IPA
        script: |
          xcode-project build-ipa \
            --workspace "$XCODE_WORKSPACE" \
            --scheme "$XCODE_SCHEME"
    
    artifacts:
      - build/ios/ipa/*.ipa
      - /tmp/xcodebuild_logs/*.log
    
    publishing:
      app_store_connect:
        auth: integration
        submit_to_testflight: true
