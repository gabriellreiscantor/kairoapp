workflows:
  ios-workflow:
    name: iOS Build
    instance_type: mac_mini_m2
    max_build_duration: 120
    integrations:
      app_store_connect: iOS Kairo
    environment:
      ios_signing:
        distribution_type: app_store
        bundle_identifier: com.kairo
      vars:
        XCODE_WORKSPACE: "ios/App/App.xcworkspace"
        XCODE_SCHEME: "App"
        VITE_SUPABASE_URL: "https://codkpccwtffhoacwswso.supabase.co"
        VITE_SUPABASE_PUBLISHABLE_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNvZGtwY2N3dGZmaG9hY3dzd3NvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4NDEwNjIsImV4cCI6MjA4MTQxNzA2Mn0.X_FY1v9E0HLlHFoK6ZQMqPEXKRCxN9RaXj4IQi7VK9w"
        VITE_SUPABASE_PROJECT_ID: "codkpccwtffhoacwswso"
      node: v22
      xcode: latest
      cocoapods: default
    
    scripts:
      - name: Install dependencies
        script: npm install
      
      - name: Patch CallKit VoIP Plugin for Custom Ringtone and TTS
        script: |
          echo "=== Patching capacitor-plugin-callkit-voip for ringtone + TTS support ==="
          
          PLUGIN_FILE="node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift"
          
          if [ ! -f "$PLUGIN_FILE" ]; then
            echo "❌ Plugin file not found at $PLUGIN_FILE"
            exit 1
          fi
          
          echo "Creating patched CallKitVoipPlugin.swift..."
          
          cat > "$PLUGIN_FILE" << 'SWIFT_EOF'
          import Foundation
          import Capacitor
          import UIKit
          import CallKit
          import PushKit
          import AVFoundation

          @objc(CallKitVoipPlugin)
          public class CallKitVoipPlugin: CAPPlugin, CXProviderDelegate, PKPushRegistryDelegate {
              private var provider: CXProvider?
              private var callController = CXCallController()
              private var currentCallUUID: UUID?
              private var silencePlayer: AVAudioPlayer?
              
              @objc override public func load() {
                  let config = CXProviderConfiguration(localizedName: "Kairo")
                  config.supportsVideo = false
                  config.supportedHandleTypes = [.generic]
                  config.maximumCallGroups = 1
                  config.maximumCallsPerCallGroup = 1
                  config.ringtoneSound = "toqueios.caf"
                  
                  provider = CXProvider(configuration: config)
                  provider?.setDelegate(self, queue: nil)
                  
                  let voipRegistry = PKPushRegistry(queue: DispatchQueue.main)
                  voipRegistry.delegate = self
                  voipRegistry.desiredPushTypes = [.voIP]
              }
              
              // Start audio anchor - plays silence.caf in loop to keep call alive
              private func startAudioAnchor() {
                  do {
                      let session = AVAudioSession.sharedInstance()
                      try session.setCategory(.playback, mode: .default, options: [.mixWithOthers])
                      try session.setActive(true)
                      print("[CallKit] Audio session activated for anchor")
                      
                      // Debug: list bundle resources
                      if let resourcePath = Bundle.main.resourcePath {
                          let files = try? FileManager.default.contentsOfDirectory(atPath: resourcePath)
                          let cafFiles = files?.filter { $0.hasSuffix(".caf") } ?? []
                          print("[CallKit] CAF files in bundle: \(cafFiles)")
                      }
                      
                      // Play silence.caf in infinite loop to keep call anchored
                      if let url = Bundle.main.url(forResource: "silence", withExtension: "caf") {
                          print("[CallKit] Found silence.caf at: \(url.path)")
                          silencePlayer = try AVAudioPlayer(contentsOf: url)
                          silencePlayer?.numberOfLoops = -1  // Infinite loop
                          silencePlayer?.volume = 0.01  // Almost inaudible
                          let started = silencePlayer?.play() ?? false
                          print("[CallKit] Silence audio anchor started: \(started)")
                      } else {
                          print("[CallKit] ❌ silence.caf NOT found in bundle!")
                      }
                  } catch {
                      print("[CallKit] Failed to start audio anchor: \(error)")
                  }
              }
              
              // Stop audio anchor
              private func stopAudioAnchor() {
                  silencePlayer?.stop()
                  silencePlayer = nil
                  print("[CallKit] Silence audio anchor stopped")
              }
              
              // Configure audio session for TTS playback during call
              private func configureAudioSession() {
                  do {
                      let session = AVAudioSession.sharedInstance()
                      try session.setCategory(.playAndRecord, mode: .voiceChat, options: [.defaultToSpeaker, .allowBluetoothA2DP])
                      try session.setActive(true)
                      print("[CallKit] Audio session configured for TTS playback")
                  } catch {
                      print("[CallKit] Failed to configure audio session: \(error)")
                  }
              }
              
              // MARK: - PKPushRegistryDelegate
              
              public func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
                  let token = pushCredentials.token.map { String(format: "%02.2hhx", $0) }.joined()
                  print("[CallKit] VoIP token: \(token)")
                  notifyListeners("registration", data: ["value": token])
              }
              
              public func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {
                  print("[CallKit] Received VoIP push: \(payload.dictionaryPayload)")
                  
                  guard let idString = payload.dictionaryPayload["id"] as? String,
                        let uuid = UUID(uuidString: idString) else {
                      print("[CallKit] Invalid or missing 'id' in payload")
                      // Must report a call even if invalid, per Apple requirements
                      let fallbackUUID = UUID()
                      let update = CXCallUpdate()
                      update.remoteHandle = CXHandle(type: .generic, value: "Unknown")
                      provider?.reportNewIncomingCall(with: fallbackUUID, update: update) { _ in
                          self.provider?.reportCall(with: fallbackUUID, endedAt: nil, reason: .failed)
                          completion()
                      }
                      return
                  }
                  
                  // Validate callerName - empty string causes "Unknown" in CallKit
                  let rawName = payload.dictionaryPayload["name"] as? String ?? ""
                  let callerName = rawName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty 
                      ? "Lembrete Kairo" 
                      : rawName
                  print("[CallKit] Caller name: '\(callerName)' (raw: '\(rawName)')")
                  
                  currentCallUUID = uuid
                  
                  // Start audio anchor BEFORE reporting the call
                  startAudioAnchor()
                  
                  let update = CXCallUpdate()
                  update.remoteHandle = CXHandle(type: .generic, value: callerName)
                  update.localizedCallerName = callerName
                  update.hasVideo = false
                  update.supportsHolding = false
                  update.supportsGrouping = false
                  update.supportsUngrouping = false
                  update.supportsDTMF = false
                  
                  provider?.reportNewIncomingCall(with: uuid, update: update) { error in
                      if let error = error {
                          print("[CallKit] Failed to report incoming call: \(error)")
                          self.stopAudioAnchor()
                      } else {
                          print("[CallKit] Incoming call reported successfully with audio anchor")
                      }
                      completion()
                  }
              }
              
              public func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {
                  print("[CallKit] VoIP token invalidated")
              }
              
              // MARK: - CXProviderDelegate
              
              public func providerDidReset(_ provider: CXProvider) {
                  print("[CallKit] Provider did reset")
                  stopAudioAnchor()
                  currentCallUUID = nil
              }
              
              public func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {
                  print("[CallKit] Call answered")
                  
                  // Stop silence anchor before configuring for TTS
                  stopAudioAnchor()
                  
                  // Configure audio session for TTS playback
                  configureAudioSession()
                  
                  // Notify JavaScript that call was answered
                  // DO NOT end the call here - let JavaScript handle it after TTS
                  if let uuid = currentCallUUID {
                      notifyListeners("callAnswered", data: [
                          "id": uuid.uuidString,
                          "connectionId": uuid.uuidString
                      ])
                  }
                  
                  action.fulfill()
                  
                  // Notify that call has started (audio connected)
                  notifyListeners("callStarted", data: [
                      "id": currentCallUUID?.uuidString ?? "",
                      "connectionId": currentCallUUID?.uuidString ?? ""
                  ])
              }
              
              public func provider(_ provider: CXProvider, perform action: CXEndCallAction) {
                  print("[CallKit] Call ended")
                  
                  // Stop audio anchor
                  stopAudioAnchor()
                  
                  if let uuid = currentCallUUID {
                      notifyListeners("callEnded", data: [
                          "id": uuid.uuidString,
                          "connectionId": uuid.uuidString
                      ])
                  }
                  
                  currentCallUUID = nil
                  action.fulfill()
              }
              
              public func provider(_ provider: CXProvider, perform action: CXStartCallAction) {
                  action.fulfill()
              }
              
              public func provider(_ provider: CXProvider, perform action: CXSetHeldCallAction) {
                  action.fulfill()
              }
              
              public func provider(_ provider: CXProvider, perform action: CXSetMutedCallAction) {
                  action.fulfill()
              }
              
              // MARK: - Plugin Methods
              
              @objc func register(_ call: CAPPluginCall) {
                  // VoIP registration is automatic in load()
                  call.resolve()
              }
              
              @objc func endCall(_ call: CAPPluginCall) {
                  guard let uuid = currentCallUUID else {
                      call.reject("No active call")
                      return
                  }
                  
                  stopAudioAnchor()
                  
                  let endCallAction = CXEndCallAction(call: uuid)
                  let transaction = CXTransaction(action: endCallAction)
                  
                  callController.request(transaction) { error in
                      if let error = error {
                          print("[CallKit] Failed to end call: \(error)")
                          call.reject("Failed to end call: \(error.localizedDescription)")
                      } else {
                          print("[CallKit] Call ended successfully via endCall")
                          call.resolve()
                      }
                  }
              }
              
              // New method for JavaScript to end call after TTS playback
              @objc func endCallFromJS(_ call: CAPPluginCall) {
                  print("[CallKit] endCallFromJS called from JavaScript")
                  
                  guard let uuid = currentCallUUID else {
                      print("[CallKit] No active call to end")
                      call.reject("No active call")
                      return
                  }
                  
                  stopAudioAnchor()
                  
                  let endCallAction = CXEndCallAction(call: uuid)
                  let transaction = CXTransaction(action: endCallAction)
                  
                  callController.request(transaction) { error in
                      if let error = error {
                          print("[CallKit] Failed to end call from JS: \(error)")
                          call.reject("Failed to end call: \(error.localizedDescription)")
                      } else {
                          print("[CallKit] Call ended successfully from JavaScript")
                          call.resolve()
                      }
                  }
              }
          }
          SWIFT_EOF
          
          echo "=== Patching plugin.m to expose endCallFromJS ==="
          
          PLUGIN_M_FILE="node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m"
          
          cat > "$PLUGIN_M_FILE" << 'OBJC_EOF'
          #import <Foundation/Foundation.h>
          #import <Capacitor/Capacitor.h>

          CAP_PLUGIN(CallKitVoipPlugin, "CallKitVoip",
              CAP_PLUGIN_METHOD(register, CAPPluginReturnPromise);
              CAP_PLUGIN_METHOD(endCall, CAPPluginReturnPromise);
              CAP_PLUGIN_METHOD(endCallFromJS, CAPPluginReturnPromise);
          )
          OBJC_EOF
          
          echo "✅ CallKit VoIP plugin patched successfully"
          echo "   - Custom ringtone: toqueios.caf"
          echo "   - Audio session configured for TTS"
          echo "   - endCallFromJS method exposed"
          echo "   - Call stays active until JS ends it"
      
      - name: Install capacitor-assets
        script: npm install -g @capacitor/assets
      
      - name: Build web assets
        script: npm run build
      
      - name: Add and Sync Capacitor iOS
        script: |
          rm -rf ios
          export NODE_ENV=production
          npx cap add ios --packagemanager cocoapods
          npx cap sync ios
      
      - name: Generate Silence Audio File for CallKit Anchor
        script: |
          echo "=== Generating silence.caf for CallKit audio anchor ==="
          
          mkdir -p resources
          
          # Method 1: Try sox first (most reliable)
          if command -v sox &> /dev/null; then
            echo "Using sox to generate silence.caf..."
            sox -n -r 44100 -c 1 -b 16 resources/silence.caf trim 0.0 2.0
            echo "✅ silence.caf created with sox"
          else
            echo "sox not found, using Python to create silence.caf..."
            # Method 2: Create with Python (always available on macOS)
            python3 << 'PYTHON_SCRIPT'
          import struct
          import os
          
          # CAF file format for 2 seconds of silence at 44100 Hz, 16-bit mono
          sample_rate = 44100
          duration = 2
          channels = 1
          bits_per_sample = 16
          num_samples = sample_rate * duration
          
          # CAF header
          caf_header = b'caff'  # File type
          caf_header += struct.pack('>H', 1)  # File version
          caf_header += struct.pack('>H', 0)  # Flags
          
          # Audio Description chunk
          desc_chunk = b'desc'
          desc_chunk += struct.pack('>Q', 32)  # Chunk size
          desc_chunk += struct.pack('>d', float(sample_rate))  # Sample rate
          desc_chunk += b'lpcm'  # Format ID (Linear PCM)
          desc_chunk += struct.pack('>I', 12)  # Format flags (little endian, signed integer)
          desc_chunk += struct.pack('>I', 2)  # Bytes per packet
          desc_chunk += struct.pack('>I', 1)  # Frames per packet
          desc_chunk += struct.pack('>I', channels)  # Channels per frame
          desc_chunk += struct.pack('>I', bits_per_sample)  # Bits per channel
          
          # Data chunk
          audio_data = b'\x00' * (num_samples * channels * (bits_per_sample // 8))
          data_chunk = b'data'
          data_chunk += struct.pack('>Q', len(audio_data) + 4)  # Chunk size
          data_chunk += struct.pack('>I', 0)  # Edit count
          data_chunk += audio_data
          
          # Write file
          os.makedirs('resources', exist_ok=True)
          with open('resources/silence.caf', 'wb') as f:
              f.write(caf_header + desc_chunk + data_chunk)
          
          print("silence.caf created with Python")
          PYTHON_SCRIPT
            echo "✅ silence.caf created with Python"
          fi
          
          if [ -f "resources/silence.caf" ]; then
            echo "✅ resources/silence.caf verified successfully"
            ls -la resources/silence.caf
          else
            echo "❌ Failed to create silence.caf"
            exit 1
          fi
      
      - name: Copy Ringtone and Silence to iOS Bundle
        script: |
          echo "=== Copying audio files to iOS bundle ==="
          
          # Copy toqueios.caf (ringtone)
          if [ -f "resources/toqueios.caf" ]; then
            cp resources/toqueios.caf ios/App/App/toqueios.caf
            echo "✅ toqueios.caf copied to ios/App/App/"
          else
            echo "❌ resources/toqueios.caf not found!"
            exit 1
          fi
          
          # Copy silence.caf (audio anchor)
          if [ -f "resources/silence.caf" ]; then
            cp resources/silence.caf ios/App/App/silence.caf
            echo "✅ silence.caf copied to ios/App/App/"
          else
            echo "❌ resources/silence.caf not found!"
            exit 1
          fi
          
          echo "=== Adding audio files to Xcode project ==="
          
          ruby <<'RUBY'
          require 'xcodeproj'
          
          begin
            project_path = 'ios/App/App.xcodeproj'
            puts "Opening project: #{project_path}"
            project = Xcodeproj::Project.open(project_path)
            
            target = project.targets.first
            puts "Target: #{target.name}"
            
            app_group = project.main_group['App']
            
            # Get resources build phase
            resources_phase = target.resources_build_phase
            
            # Add toqueios.caf to Resources (not Compile Sources)
            existing_ringtone = app_group.files.find { |f| f.path == 'toqueios.caf' }
            if existing_ringtone.nil?
              puts "Adding toqueios.caf to project as resource..."
              file_ref = app_group.new_file('toqueios.caf')
              file_ref.last_known_file_type = 'audio.caf'
              build_file = resources_phase.add_file_reference(file_ref)
              puts "✅ toqueios.caf added to Resources build phase"
            else
              puts "ℹ️ toqueios.caf already exists in project"
            end
            
            # Add silence.caf to Resources (not Compile Sources)
            existing_silence = app_group.files.find { |f| f.path == 'silence.caf' }
            if existing_silence.nil?
              puts "Adding silence.caf to project as resource..."
              file_ref = app_group.new_file('silence.caf')
              file_ref.last_known_file_type = 'audio.caf'
              build_file = resources_phase.add_file_reference(file_ref)
              puts "✅ silence.caf added to Resources build phase"
            else
              puts "ℹ️ silence.caf already exists in project"
            end
            
            project.save
            puts "✅ Project saved successfully"
            
          rescue => e
            puts "❌ Error: #{e.message}"
            puts e.backtrace.first(5).join("\n")
            exit 1
          end
          RUBY
          
          echo "✅ Audio files configuration complete"
      
      - name: Add Camera and Photo Library Permissions to Info.plist
        script: |
          /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'This app needs camera access to capture images'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'This app needs photo library access to select images'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'This app needs permission to save photos'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'This app needs microphone access for audio recording'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationWhenInUseUsageDescription string 'Kairo needs your location to provide location-based reminders and alerts'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationAlwaysAndWhenInUseUsageDescription string 'Kairo needs your location to provide location-based reminders and alerts even when the app is in the background'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes array" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:0 string 'voip'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:1 string 'remote-notification'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:2 string 'fetch'" ios/App/App/Info.plist || true
          echo "All permissions and background modes added to Info.plist"
      
      - name: Copy and Add GoogleService-Info.plist to Xcode Project
        script: |
          cp GoogleService-Info.plist ios/App/App/GoogleService-Info.plist
          
          ruby <<EOF
          require 'xcodeproj'
          project_path = 'ios/App/App.xcodeproj'
          project = Xcodeproj::Project.open(project_path)
          
          target = project.targets.first
          
          file_ref = project.main_group['App'].new_file('GoogleService-Info.plist')
          target.add_file_references([file_ref])
          
          project.save
          EOF
          echo "GoogleService-Info.plist added to Xcode project and target"
      
      - name: Add Firebase and CallKit VoIP to Podfile
        script: |
          PODFILE_PATH="ios/App/Podfile"
          
          echo "=== Creating Podfile with Firebase + CallKit VoIP ==="
          cat > "$PODFILE_PATH" << 'PODFILE_CONTENT'
          require_relative '../../node_modules/@capacitor/ios/scripts/pods_helpers'

          platform :ios, '13.0'
          use_frameworks!

          install! 'cocoapods', :disable_input_output_paths => true

          def capacitor_pods
            pod 'Capacitor', :path => '../../node_modules/@capacitor/ios'
            pod 'CapacitorCordova', :path => '../../node_modules/@capacitor/ios'
            pod 'CapacitorGeolocation', :path => '../../node_modules/@capacitor/geolocation'
            pod 'CapacitorHaptics', :path => '../../node_modules/@capacitor/haptics'
            pod 'CapacitorLocalNotifications', :path => '../../node_modules/@capacitor/local-notifications'
            pod 'CapacitorPushNotifications', :path => '../../node_modules/@capacitor/push-notifications'
            pod 'CapacitorPluginCallkitVoip', :path => '../../node_modules/capacitor-plugin-callkit-voip'
          end

          target 'App' do
            capacitor_pods
            pod 'Firebase/Messaging'
          end

          post_install do |installer|
            assertDeploymentTarget(installer)
          end
          PODFILE_CONTENT
          echo "=== Podfile created with CallKit VoIP plugin ==="
          cat "$PODFILE_PATH"
      
      - name: Configure AppDelegate for Firebase Messaging (Plugin handles VoIP)
        script: |
          cat > ios/App/App/AppDelegate.swift << 'EOF'
          import UIKit
          import Capacitor
          import Firebase
          import FirebaseMessaging
          import UserNotifications

          @UIApplicationMain
          class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate, MessagingDelegate {

              var window: UIWindow?

              func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
                  FirebaseApp.configure()
                  
                  UNUserNotificationCenter.current().delegate = self
                  Messaging.messaging().delegate = self
                  
                  let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]
                  UNUserNotificationCenter.current().requestAuthorization(options: authOptions) { _, _ in }
                  application.registerForRemoteNotifications()
                  
                  // VoIP/CallKit is handled automatically by capacitor-plugin-callkit-voip
                  // Do NOT setup PKPushRegistry or CXProvider here - the plugin does it
                  
                  return true
              }

              func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
                  Messaging.messaging().apnsToken = deviceToken
                  NotificationCenter.default.post(name: .capacitorDidRegisterForRemoteNotifications, object: deviceToken)
              }

              func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
                  NotificationCenter.default.post(name: .capacitorDidFailToRegisterForRemoteNotifications, object: error)
              }

              func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
                  completionHandler([.banner, .badge, .sound])
              }

              func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
                  NotificationCenter.default.post(name: Notification.Name("pushNotificationReceived"), object: response.notification.request.content.userInfo)
                  completionHandler()
              }

              func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {
                  if let token = fcmToken {
                      NotificationCenter.default.post(name: Notification.Name("FCMToken"), object: nil, userInfo: ["token": token])
                  }
              }

              func applicationWillResignActive(_ application: UIApplication) {}
              func applicationDidEnterBackground(_ application: UIApplication) {}
              func applicationWillEnterForeground(_ application: UIApplication) {}
              func applicationDidBecomeActive(_ application: UIApplication) {}
              func applicationWillTerminate(_ application: UIApplication) {}
              func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
                  return ApplicationDelegateProxy.shared.application(app, open: url, options: options)
              }
              func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
                  return ApplicationDelegateProxy.shared.application(application, continue: userActivity, restorationHandler: restorationHandler)
              }
          }
          EOF
      
      - name: Add Push Notification Entitlements
        script: |
          echo "=== Creating App.entitlements file ==="
          
          # Create entitlements file (only aps-environment, VoIP is inferred via Background Mode)
          cat > ios/App/App/App.entitlements << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>aps-environment</key>
              <string>production</string>
          </dict>
          </plist>
          EOF
          
          echo "=== App.entitlements file created ==="
          cat ios/App/App/App.entitlements
          
          echo "=== Linking entitlements to Xcode project ==="
          
          # Link entitlements to Xcode target with error handling
          ruby <<'RUBY'
          require 'xcodeproj'
          
          begin
            project_path = 'ios/App/App.xcodeproj'
            puts "Opening project: #{project_path}"
            project = Xcodeproj::Project.open(project_path)
            
            target = project.targets.first
            puts "Target: #{target.name}"
            
            app_group = project.main_group['App']
            entitlements_path = 'App/App.entitlements'
            
            # Check if entitlements file already exists in project
            existing_file = app_group.files.find { |f| f.path == 'App.entitlements' }
            
            if existing_file.nil?
              puts "Adding App.entitlements to project..."
              file_ref = app_group.new_file('App.entitlements')
              puts "✅ App.entitlements added to project"
            else
              puts "ℹ️ App.entitlements already exists in project, skipping add"
            end
            
            # Set CODE_SIGN_ENTITLEMENTS build setting for all configurations
            target.build_configurations.each do |config|
              config.build_settings['CODE_SIGN_ENTITLEMENTS'] = entitlements_path
              puts "Set CODE_SIGN_ENTITLEMENTS for #{config.name}"
            end
            
            project.save
            puts "✅ Project saved successfully"
            puts "✅ App.entitlements linked to target with CODE_SIGN_ENTITLEMENTS"
            
          rescue => e
            puts "❌ Error: #{e.message}"
            puts e.backtrace.first(5).join("\n")
            exit 1
          end
          RUBY
          
          echo "=== Entitlements configuration complete ==="
      
      - name: Set iOS version
        script: |
          cd ios/App
          agvtool new-version -all $BUILD_NUMBER
          agvtool new-marketing-version 1.0.1
      
      - name: Generate App Icons and Splash Screens
        script: npx capacitor-assets generate --ios
      
      - name: Install CocoaPods
        script: |
          rm -rf ios/App/CapApp-SPM
          cd ios/App && pod install
      
      - name: Initialize keychain
        script: keychain initialize
      
      - name: Add certificates to keychain
        script: keychain add-certificates
      
      - name: Set up code signing settings on Xcode project
        script: xcode-project use-profiles
      
      - name: Build IPA
        script: |
          xcode-project build-ipa \
            --workspace "$XCODE_WORKSPACE" \
            --scheme "$XCODE_SCHEME"
    
    artifacts:
      - build/ios/ipa/*.ipa
      - /tmp/xcodebuild_logs/*.log
    
    publishing:
      app_store_connect:
        auth: integration
        submit_to_testflight: true
