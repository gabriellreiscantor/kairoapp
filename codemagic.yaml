workflows:
  ios-workflow:
    name: iOS Build
    instance_type: mac_mini_m2
    max_build_duration: 120
    integrations:
      app_store_connect: iOS Kairo
    environment:
      ios_signing:
        distribution_type: app_store
        bundle_identifier: com.kairo
      vars:
        XCODE_WORKSPACE: "ios/App/App.xcworkspace"
        XCODE_SCHEME: "App"
        VITE_SUPABASE_URL: "https://codkpccwtffhoacwswso.supabase.co"
        VITE_SUPABASE_PUBLISHABLE_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNvZGtwY2N3dGZmaG9hY3dzd3NvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4NDEwNjIsImV4cCI6MjA4MTQxNzA2Mn0.X_FY1v9E0HLlHFoK6ZQMqPEXKRCxN9RaXj4IQi7VK9w"
        VITE_SUPABASE_PROJECT_ID: "codkpccwtffhoacwswso"
      node: v22
      xcode: latest
      cocoapods: default
    
    scripts:
      - name: Install dependencies
        script: npm install
      
      - name: Install capacitor-assets
        script: npm install -g @capacitor/assets
      
      - name: Build web assets
        script: npm run build
      
      - name: Add and Sync Capacitor iOS
        script: |
          rm -rf ios
          export NODE_ENV=production
          npx cap add ios --packagemanager cocoapods
          npx cap sync ios
      
      - name: Add Camera and Photo Library Permissions to Info.plist
        script: |
          /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'This app needs camera access to capture images'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'This app needs photo library access to select images'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'This app needs permission to save photos'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'This app needs microphone access for audio recording'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationWhenInUseUsageDescription string 'Kairo needs your location to provide location-based reminders and alerts'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationAlwaysAndWhenInUseUsageDescription string 'Kairo needs your location to provide location-based reminders and alerts even when the app is in the background'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes array" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:0 string 'voip'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:1 string 'remote-notification'" ios/App/App/Info.plist || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:2 string 'fetch'" ios/App/App/Info.plist || true
          echo "All permissions and background modes added to Info.plist"
      
      - name: Copy and Add GoogleService-Info.plist to Xcode Project
        script: |
          cp GoogleService-Info.plist ios/App/App/GoogleService-Info.plist
          
          ruby <<EOF
          require 'xcodeproj'
          project_path = 'ios/App/App.xcodeproj'
          project = Xcodeproj::Project.open(project_path)
          
          target = project.targets.first
          
          file_ref = project.main_group['App'].new_file('GoogleService-Info.plist')
          target.add_file_references([file_ref])
          
          project.save
          EOF
          echo "GoogleService-Info.plist added to Xcode project and target"
      
      - name: Add Firebase and CallKit VoIP to Podfile
        script: |
          PODFILE_PATH="ios/App/Podfile"
          
          echo "=== Creating Podfile with Firebase + CallKit VoIP ==="
          cat > "$PODFILE_PATH" << 'PODFILE_CONTENT'
          require_relative '../../node_modules/@capacitor/ios/scripts/pods_helpers'

          platform :ios, '13.0'
          use_frameworks!

          install! 'cocoapods', :disable_input_output_paths => true

          def capacitor_pods
            pod 'Capacitor', :path => '../../node_modules/@capacitor/ios'
            pod 'CapacitorCordova', :path => '../../node_modules/@capacitor/ios'
            pod 'CapacitorGeolocation', :path => '../../node_modules/@capacitor/geolocation'
            pod 'CapacitorHaptics', :path => '../../node_modules/@capacitor/haptics'
            pod 'CapacitorLocalNotifications', :path => '../../node_modules/@capacitor/local-notifications'
            pod 'CapacitorPushNotifications', :path => '../../node_modules/@capacitor/push-notifications'
            pod 'CapacitorPluginCallkitVoip', :path => '../../node_modules/capacitor-plugin-callkit-voip'
          end

          target 'App' do
            capacitor_pods
            pod 'Firebase/Messaging'
          end

          post_install do |installer|
            assertDeploymentTarget(installer)
          end
          PODFILE_CONTENT
          echo "=== Podfile created with CallKit VoIP plugin ==="
          cat "$PODFILE_PATH"
      
      - name: Configure AppDelegate for Firebase Messaging (Plugin handles VoIP)
        script: |
          cat > ios/App/App/AppDelegate.swift << 'EOF'
          import UIKit
          import Capacitor
          import Firebase
          import FirebaseMessaging
          import UserNotifications

          @UIApplicationMain
          class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate, MessagingDelegate {

              var window: UIWindow?

              func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
                  FirebaseApp.configure()
                  
                  UNUserNotificationCenter.current().delegate = self
                  Messaging.messaging().delegate = self
                  
                  let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]
                  UNUserNotificationCenter.current().requestAuthorization(options: authOptions) { _, _ in }
                  application.registerForRemoteNotifications()
                  
                  // VoIP/CallKit is handled automatically by capacitor-plugin-callkit-voip
                  // Do NOT setup PKPushRegistry or CXProvider here - the plugin does it
                  
                  return true
              }

              func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
                  Messaging.messaging().apnsToken = deviceToken
                  NotificationCenter.default.post(name: .capacitorDidRegisterForRemoteNotifications, object: deviceToken)
              }

              func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
                  NotificationCenter.default.post(name: .capacitorDidFailToRegisterForRemoteNotifications, object: error)
              }

              func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
                  completionHandler([.banner, .badge, .sound])
              }

              func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
                  NotificationCenter.default.post(name: Notification.Name("pushNotificationReceived"), object: response.notification.request.content.userInfo)
                  completionHandler()
              }

              func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {
                  if let token = fcmToken {
                      NotificationCenter.default.post(name: Notification.Name("FCMToken"), object: nil, userInfo: ["token": token])
                  }
              }

              func applicationWillResignActive(_ application: UIApplication) {}
              func applicationDidEnterBackground(_ application: UIApplication) {}
              func applicationWillEnterForeground(_ application: UIApplication) {}
              func applicationDidBecomeActive(_ application: UIApplication) {}
              func applicationWillTerminate(_ application: UIApplication) {}
              func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
                  return ApplicationDelegateProxy.shared.application(app, open: url, options: options)
              }
              func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
                  return ApplicationDelegateProxy.shared.application(application, continue: userActivity, restorationHandler: restorationHandler)
              }
          }
          EOF
      
      - name: Add Push Notification Entitlements
        script: |
          echo "=== Creating App.entitlements file ==="
          
          # Create entitlements file (only aps-environment, VoIP is inferred via Background Mode)
          cat > ios/App/App/App.entitlements << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>aps-environment</key>
              <string>production</string>
          </dict>
          </plist>
          EOF
          
          echo "=== App.entitlements file created ==="
          cat ios/App/App/App.entitlements
          
          echo "=== Linking entitlements to Xcode project ==="
          
          # Link entitlements to Xcode target with error handling
          ruby <<'RUBY'
          require 'xcodeproj'
          
          begin
            project_path = 'ios/App/App.xcodeproj'
            puts "Opening project: #{project_path}"
            project = Xcodeproj::Project.open(project_path)
            
            target = project.targets.first
            puts "Target: #{target.name}"
            
            app_group = project.main_group['App']
            entitlements_path = 'App/App.entitlements'
            
            # Check if entitlements file already exists in project
            existing_file = app_group.files.find { |f| f.path == 'App.entitlements' }
            
            if existing_file.nil?
              puts "Adding App.entitlements to project..."
              file_ref = app_group.new_file('App.entitlements')
              puts "✅ App.entitlements added to project"
            else
              puts "ℹ️ App.entitlements already exists in project, skipping add"
            end
            
            # Set CODE_SIGN_ENTITLEMENTS build setting for all configurations
            target.build_configurations.each do |config|
              config.build_settings['CODE_SIGN_ENTITLEMENTS'] = entitlements_path
              puts "Set CODE_SIGN_ENTITLEMENTS for #{config.name}"
            end
            
            project.save
            puts "✅ Project saved successfully"
            puts "✅ App.entitlements linked to target with CODE_SIGN_ENTITLEMENTS"
            
          rescue => e
            puts "❌ Error: #{e.message}"
            puts e.backtrace.first(5).join("\n")
            exit 1
          end
          RUBY
          
          echo "=== Entitlements configuration complete ==="
      
      - name: Set iOS version
        script: |
          cd ios/App
          agvtool new-version -all $BUILD_NUMBER
          agvtool new-marketing-version 1.0.1
      
      - name: Generate App Icons and Splash Screens
        script: npx capacitor-assets generate --ios
      
      - name: Install CocoaPods
        script: |
          rm -rf ios/App/CapApp-SPM
          cd ios/App && pod install
      
      - name: Initialize keychain
        script: keychain initialize
      
      - name: Add certificates to keychain
        script: keychain add-certificates
      
      - name: Set up code signing settings on Xcode project
        script: xcode-project use-profiles
      
      - name: Build IPA
        script: |
          xcode-project build-ipa \
            --workspace "$XCODE_WORKSPACE" \
            --scheme "$XCODE_SCHEME"
    
    artifacts:
      - build/ios/ipa/*.ipa
      - /tmp/xcodebuild_logs/*.log
    
    publishing:
      app_store_connect:
        auth: integration
        submit_to_testflight: true
