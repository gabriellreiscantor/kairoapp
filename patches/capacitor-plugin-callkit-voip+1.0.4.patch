diff --git a/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m b/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m
index 1234567..abcdefg 100644
--- a/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m
+++ b/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m
@@ -1,6 +1,12 @@
 #import <Foundation/Foundation.h>
 #import <Capacitor/Capacitor.h>
 
+// MODIFIED BY HORAH: TTS playback OUTSIDE CallKit context
+// - playTTSAsMedia: Play TTS as normal app media (not during call)
+// - endCallFromJS: End call from JavaScript
+// - configureAudioSession: Configure audio for TTS (legacy)
+// - playTTSAudio: Play TTS during call (legacy, kept for compatibility)
+// - stopTTSAudio: Stop TTS audio
 CAP_PLUGIN(CallKitVoipPlugin, "CallKitVoip",
     CAP_PLUGIN_METHOD(register, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(playTTSAsMedia, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(endCallFromJS, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(configureAudioSession, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(playTTSAudio, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(stopTTSAudio, CAPPluginReturnPromise);
 )
diff --git a/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift b/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift
index 1234567..abcdefg 100644
--- a/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift
+++ b/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift
@@ -1,200 +1,350 @@
 import Foundation
 import Capacitor
 import UIKit
 import CallKit
 import PushKit
+import AVFoundation

 /**
  *  CallKit Voip Plugin provides native PushKit functionality with apple CallKit to capacitor
+ *  MODIFIED BY HORAH v3: TTS plays OUTSIDE CallKit context as app media
+ *  CallKit = UX only (native call screen)
+ *  TTS = App media playback (AVAudioSession.Category.playback)
  */
@objc(CallKitVoipPlugin)
 public class CallKitVoipPlugin: CAPPlugin, AVAudioPlayerDelegate {

     private var provider: CXProvider?
     private let voipRegistry = PKPushRegistry(queue: nil)
     private var connectionIdRegistry: [UUID: CallConfig] = [:]
+    private var activeCallUUID: UUID?
+    private var audioPlayer: AVAudioPlayer?  // For TTS playback (as media)

     @objc func register(_ call: CAPPluginCall) {
         voipRegistry.delegate = self
         voipRegistry.desiredPushTypes = [.voIP]
         let config = CXProviderConfiguration(localizedName: "Horah")
         config.maximumCallGroups = 1
         config.maximumCallsPerCallGroup = 1
         config.supportsVideo = false
         config.supportedHandleTypes = [.generic]
+        
+        // Configure ringtone
+        config.ringtoneSound = "toqueios.caf"
+        
         provider = CXProvider(configuration: config)
         provider?.setDelegate(self, queue: DispatchQueue.main)
         call.resolve()
     }

     public func notifyEvent(eventName: String, uuid: UUID) {
         if let config = connectionIdRegistry[uuid] {
             notifyListeners(eventName, data: [
                 "id": config.id,
                 "media": config.media,
                 "name": config.name,
                 "duration": config.duration,
                 "connectionId": uuid.uuidString,
             ])
-            connectionIdRegistry[uuid] = nil
+            // DON'T remove from registry here - we need it for cleanup
         }
     }

     public func incomingCall(id: String, media: String, name: String, duration: String) {
         let update = CXCallUpdate()
         update.remoteHandle = CXHandle(type: .generic, value: name)
         update.hasVideo = false
         update.supportsDTMF = false
         update.supportsHolding = false
         update.supportsGrouping = false
         update.supportsUngrouping = false
+        
         let uuid = UUID()
+        activeCallUUID = uuid
         connectionIdRegistry[uuid] = .init(id: id, media: media, name: name, duration: duration)
+        
+        print("[CallKit-Swift] üìû Incoming call: \(name) (id: \(id))")
+        
         self.provider?.reportNewIncomingCall(with: uuid, update: update, completion: { error in
-            if error != nil {
-                print("Error reportNewIncomingCall: \(error!.localizedDescription)")
+            if let error = error {
+                print("[CallKit-Swift] ‚ùå Error reporting call: \(error)")
+            } else {
+                print("[CallKit-Swift] ‚úÖ Call reported successfully")
             }
         })
     }

+    // ========== END CALL ==========
+    
     public func endCall(uuid: UUID) {
         let controller = CXCallController()
         let transaction = CXTransaction(action: CXEndCallAction(call: uuid))
-        controller.request(transaction, completion: { error in })
+        controller.request(transaction, completion: { error in
+            if let error = error {
+                print("[CallKit-Swift] ‚ùå Error ending call: \(error)")
+            } else {
+                print("[CallKit-Swift] ‚úÖ Call ended successfully")
+            }
+        })
+        
+        // Cleanup
+        self.activeCallUUID = nil
+        self.connectionIdRegistry[uuid] = nil
+    }
+    
+    // NEW: End call from JavaScript
+    @objc func endCallFromJS(_ call: CAPPluginCall) {
+        print("[CallKit-Swift] üì± endCallFromJS called from JavaScript")
+        
+        guard let uuid = activeCallUUID else {
+            print("[CallKit-Swift] ‚ö†Ô∏è No active call to end")
+            call.resolve(["ended": false, "reason": "no_active_call"])
+            return
+        }
+        
+        print("[CallKit-Swift] üîö Ending call: \(uuid)")
+        endCall(uuid: uuid)
+        call.resolve(["ended": true])
+    }
+    
+    // ========== TTS AS MEDIA (OUTSIDE CALLKIT) ==========
+    // This is the NEW PRIMARY method for TTS playback
+    // Uses AVAudioSession.Category.playback (media, not call)
+    
+    @objc func playTTSAsMedia(_ call: CAPPluginCall) {
+        print("[CallKit-Swift] üîä playTTSAsMedia CALLED (media mode, outside CallKit)")
+        
+        notifyListeners("debug", data: [
+            "stage": "media_tts_called",
+            "timestamp": ISO8601DateFormatter().string(from: Date())
+        ])
+        
+        guard let base64Audio = call.getString("audio") else {
+            print("[CallKit-Swift] ‚ùå No audio data provided")
+            call.resolve(["playing": false, "error": "no_audio_data"])
+            return
+        }
+        
+        print("[CallKit-Swift] üéµ Base64 audio length: \(base64Audio.count)")
+        
+        guard let audioData = Data(base64Encoded: base64Audio) else {
+            print("[CallKit-Swift] ‚ùå Invalid base64 audio")
+            call.resolve(["playing": false, "error": "invalid_base64"])
+            return
+        }
+        
+        print("[CallKit-Swift] üì¶ Audio data decoded: \(audioData.count) bytes")
+        
+        do {
+            // Stop any previous audio
+            audioPlayer?.stop()
+            audioPlayer = nil
+            
+            let audioSession = AVAudioSession.sharedInstance()
+            
+            // ‚úÖ CRITICAL: Use .playback category (NOT .playAndRecord)
+            // This is for MEDIA playback, NOT call audio
+            // .duckOthers will lower other audio while playing
+            try audioSession.setCategory(.playback, mode: .spokenAudio, options: [.duckOthers])
+            try audioSession.setActive(true)
+            
+            print("[CallKit-Swift] üîä Audio session: .playback + .spokenAudio + .duckOthers")
+            
+            // Log current route
+            let route = audioSession.currentRoute
+            let port = route.outputs.first?.portType.rawValue ?? "unknown"
+            print("[CallKit-Swift] üîà Audio route: \(port)")
+            
+            notifyListeners("debug", data: [
+                "stage": "media_audio_session_ready",
+                "category": "playback",
+                "mode": "spokenAudio",
+                "outputPort": port,
+                "audioBytes": audioData.count
+            ])
+            
+            // Create audio player
+            audioPlayer = try AVAudioPlayer(data: audioData)
+            audioPlayer?.delegate = self
+            audioPlayer?.volume = 1.0
+            audioPlayer?.prepareToPlay()
+            
+            let duration = audioPlayer?.duration ?? -1
+            print("[CallKit-Swift] ‚è±Ô∏è TTS audio duration: \(duration) seconds")
+            
+            // PLAY TTS AS MEDIA
+            let didPlay = audioPlayer?.play() ?? false
+            print("[CallKit-Swift] ‚ñ∂Ô∏è TTS media play() returned: \(didPlay)")
+            
+            notifyListeners("debug", data: [
+                "stage": "media_tts_play_result",
+                "didPlay": didPlay,
+                "duration": duration,
+                "outputPort": port,
+                "mode": "playback_media"
+            ])
+            
+            call.resolve(["playing": didPlay, "duration": duration, "mode": "media"])
+        } catch {
+            print("[CallKit-Swift] ‚ùå Media audio playback error: \(error.localizedDescription)")
+            notifyListeners("debug", data: [
+                "stage": "media_tts_error",
+                "error": error.localizedDescription
+            ])
+            call.resolve(["playing": false, "error": error.localizedDescription])
+        }
+    }
+    
+    // ========== LEGACY: TTS DURING CALL (kept for compatibility) ==========
+    
+    @objc func configureAudioSession(_ call: CAPPluginCall) {
+        print("[CallKit-Swift] üîä configureAudioSession (legacy)")
+        // No-op in new architecture - audio is configured in playTTSAsMedia
+        call.resolve(["configured": true, "note": "legacy_noop"])
+    }
+    
+    @objc func playTTSAudio(_ call: CAPPluginCall) {
+        // LEGACY: Redirect to playTTSAsMedia
+        print("[CallKit-Swift] ‚ö†Ô∏è playTTSAudio called (legacy) - redirecting to playTTSAsMedia")
+        playTTSAsMedia(call)
+    }
+    
+    // Audio player delegate
+    public func audioPlayerDecodeErrorDidOccur(_ player: AVAudioPlayer, error: Error?) {
+        print("[CallKit-Swift] ‚ùå Audio decode error: \(error?.localizedDescription ?? "nil")")
+        notifyListeners("debug", data: [
+            "stage": "tts_decode_error",
+            "error": error?.localizedDescription ?? "nil"
+        ])
+    }
+    
+    public func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
+        print("[CallKit-Swift] ‚úÖ Audio finished playing, success: \(flag)")
+        notifyListeners("debug", data: [
+            "stage": "tts_finished",
+            "success": flag
+        ])
+    }
+    
+    // Stop TTS audio
+    @objc func stopTTSAudio(_ call: CAPPluginCall) {
+        print("[CallKit-Swift] üîá Stopping TTS audio")
+        audioPlayer?.stop()
+        audioPlayer = nil
+        call.resolve(["stopped": true])
     }
 }


 // MARK: CallKit events handler

 extension CallKitVoipPlugin: CXProviderDelegate {

     public func providerDidReset(_ provider: CXProvider) {
-        print("providerDidReset")
+        print("[CallKit-Swift] Provider reset")
+        activeCallUUID = nil
+        connectionIdRegistry.removeAll()
+        audioPlayer?.stop()
+        audioPlayer = nil
     }

     public func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {
-        print("CXAnswerCallAction answers an incoming call")
+        // User answered the call
+        print("[CallKit-Swift] ====== CALL ANSWERED ======")
+        print("[CallKit-Swift] UUID: \(action.callUUID)")
+        
+        // Notify JavaScript that call was answered
+        // JS will then END the CallKit and start MEDIA playback
         notifyEvent(eventName: "callAnswered", uuid: action.callUUID)
-        endCall(uuid: action.callUUID)
+        
+        // ‚úÖ NEW ARCHITECTURE: End CallKit QUICKLY after notifying JS
+        // TTS will play as APP MEDIA, not as call audio
+        // Small delay to let JS receive the event first
+        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
+            print("[CallKit-Swift] üîö Auto-ending CallKit (300ms after answer)")
+            self?.endCall(uuid: action.callUUID)
+        }
+        
         action.fulfill()
     }

     public func provider(_ provider: CXProvider, perform action: CXEndCallAction) {
-        print("CXEndCallAction end an incoming call")
+        // Call ended (either by user, by auto-end, or by endCallFromJS)
+        print("[CallKit-Swift] ====== CALL ENDED ======")
         notifyEvent(eventName: "callEnded", uuid: action.callUUID)
+        
+        // Cleanup
+        connectionIdRegistry[action.callUUID] = nil
+        if activeCallUUID == action.callUUID {
+            activeCallUUID = nil
+        }
+        
         action.fulfill()
     }

     public func provider(_ provider: CXProvider, perform action: CXStartCallAction) {
-        print("CXStartCallAction end an outgoing call")
+        // Outgoing call started
+        print("[CallKit-Swift] ====== CALL STARTED ======")
         notifyEvent(eventName: "callStarted", uuid: action.callUUID)
         action.fulfill()
     }
+    
+    // Audio session callbacks (informational only in new architecture)
+    public func provider(_ provider: CXProvider, didActivate audioSession: AVAudioSession) {
+        print("[CallKit-Swift] üîä didActivate (CallKit audio session)")
+        // In new architecture, we don't use CallKit audio - TTS plays as media
+        notifyListeners("debug", data: [
+            "stage": "didActivate_callkit",
+            "note": "CallKit audio activated (not used for TTS in new architecture)"
+        ])
+    }
+    
+    public func provider(_ provider: CXProvider, didDeactivate audioSession: AVAudioSession) {
+        print("[CallKit-Swift] üîá didDeactivate (CallKit audio session)")
+    }
 }

 // MARK: PushKit events handler
 extension CallKitVoipPlugin: PKPushRegistryDelegate {

     public func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
         let parts = pushCredentials.token.map { String(format: "%02.2hhx", $0) }
         let token = parts.joined()
-        print("VOIP didUpdate pushCredentials: \(token)")
+        print("[CallKit-Swift] üì≤ VoIP Token: \(token.prefix(20))...")
         notifyListeners("registration", data: ["value": token])
     }

     public func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {
-        print("didReceiveIncomingPushWith: \(type.rawValue)")
-        print("didReceiveIncomingPushWith payload: \(payload.dictionaryPayload)")
+        print("[CallKit-Swift] ====== VOIP PUSH RECEIVED ======")
+        
         guard let id = payload.dictionaryPayload["id"] as? String else {
-            print("id required")
+            print("[CallKit-Swift] ‚ùå Missing 'id' in payload")
             completion()
             return
         }
+        
         let media = (payload.dictionaryPayload["media"] as? String) ?? "voice"
         let name = (payload.dictionaryPayload["name"] as? String) ?? "Evento"
         let duration = (payload.dictionaryPayload["duration"] as? String) ?? "0"
+        
+        // Extract language and other data for TTS (sent from check-upcoming-alerts)
+        let language = (payload.dictionaryPayload["language"] as? String) ?? "pt-BR"
+        let eventTime = (payload.dictionaryPayload["eventTime"] as? String) ?? duration
+        let eventEmoji = (payload.dictionaryPayload["eventEmoji"] as? String) ?? "calendario"
+        let eventLocation = (payload.dictionaryPayload["eventLocation"] as? String) ?? ""
+        
+        print("[CallKit-Swift] id: \(id)")
+        print("[CallKit-Swift] name: \(name)")
+        print("[CallKit-Swift] language: \(language)")
+        print("[CallKit-Swift] eventTime: \(eventTime)")
+        
+        // Notify JavaScript about the incoming push (for TTS pre-loading)
+        notifyListeners("callStarted", data: [
+            "eventId": id,
+            "eventTitle": name,
+            "eventTime": eventTime,
+            "eventEmoji": eventEmoji,
+            "eventLocation": eventLocation,
+            "language": language,
+        ])
+        
         self.incomingCall(id: id, media: media, name: name, duration: duration)
         completion()
     }
 }

 extension CallKitVoipPlugin {
     struct CallConfig {
         let id: String
         let media: String
         let name: String
         let duration: String
     }
 }
