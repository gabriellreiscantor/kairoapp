diff --git a/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m b/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m
index 1234567..abcdefg 100644
--- a/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m
+++ b/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.m
@@ -1,6 +1,10 @@
 #import <Foundation/Foundation.h>
 #import <Capacitor/Capacitor.h>
 
+// MODIFIED BY HORAH: Added new methods for TTS playback during native call screen
+// - endCallFromJS: End call from JavaScript after TTS finishes
+// - configureAudioSession: Configure audio for TTS during call
+// - playTTSAudio: Play TTS audio during call
+// - stopTTSAudio: Stop TTS audio
 CAP_PLUGIN(CallKitVoipPlugin, "CallKitVoip",
     CAP_PLUGIN_METHOD(register, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(endCallFromJS, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(configureAudioSession, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(playTTSAudio, CAPPluginReturnPromise);
+    CAP_PLUGIN_METHOD(stopTTSAudio, CAPPluginReturnPromise);
 )
diff --git a/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift b/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift
index 1234567..abcdefg 100644
--- a/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift
+++ b/node_modules/capacitor-plugin-callkit-voip/ios/Plugin/CallKitVoipPlugin.swift
@@ -1,200 +1,400 @@
 import Foundation
 import Capacitor
 import UIKit
 import CallKit
 import PushKit
+import AVFoundation
+import MediaPlayer
 
 /**
  *  CallKit Voip Plugin provides native PushKit functionality with apple CallKit to capacitor
+ *  MODIFIED BY HORAH: TTS plays on native call screen, call ends only after TTS finishes
+ *  v2: Added SILENCE AUDIO ANCHOR to keep call active while TTS loads
  */
@objc(CallKitVoipPlugin)
 public class CallKitVoipPlugin: CAPPlugin, AVAudioPlayerDelegate {
 
     private var provider: CXProvider?
     private let voipRegistry = PKPushRegistry(queue: nil)
     private var connectionIdRegistry: [UUID: CallConfig] = [:]
+    private var activeCallUUID: UUID?  // Track the active call
+    private var audioPlayer: AVAudioPlayer?  // For TTS playback
+    private var silencePlayer: AVAudioPlayer?  // ANCHOR: Keeps call active
+    private var silenceTimer: Timer?  // Timer to loop silence
+    private let audioQueue = DispatchQueue(label: "com.horah.audio", qos: .userInitiated)
 
     @objc func register(_ call: CAPPluginCall) {
         voipRegistry.delegate = self
         voipRegistry.desiredPushTypes = [.voIP]
         let config = CXProviderConfiguration(localizedName: "Horah")
         config.maximumCallGroups = 1
         config.maximumCallsPerCallGroup = 1
         config.supportsVideo = false
         config.supportedHandleTypes = [.generic]
+        
+        // Configure ringtone
+        config.ringtoneSound = "toqueios.caf"
+        
         provider = CXProvider(configuration: config)
         provider?.setDelegate(self, queue: DispatchQueue.main)
         call.resolve()
     }

     public func notifyEvent(eventName: String, uuid: UUID) {
         if let config = connectionIdRegistry[uuid] {
             notifyListeners(eventName, data: [
                 "id": config.id,
                 "media": config.media,
                 "name": config.name,
                 "duration": config.duration,
                 "connectionId": uuid.uuidString,
             ])
-            connectionIdRegistry[uuid] = nil
+            // DON'T remove from registry here - we need it for endCallFromJS
         }
     }

     public func incomingCall(id: String, media: String, name: String, duration: String) {
         let update = CXCallUpdate()
         update.remoteHandle = CXHandle(type: .generic, value: name)
         update.hasVideo = false
         update.supportsDTMF = false
         update.supportsHolding = false
         update.supportsGrouping = false
         update.supportsUngrouping = false
+        
         let uuid = UUID()
+        activeCallUUID = uuid
         connectionIdRegistry[uuid] = .init(id: id, media: media, name: name, duration: duration)
+        
+        print("[CallKit-Swift] üìû Incoming call: \(name) (id: \(id))")
+        
         self.provider?.reportNewIncomingCall(with: uuid, update: update, completion: { error in
-            if error != nil {
-                print("Error reportNewIncomingCall: \(error!.localizedDescription)")
+            if let error = error {
+                print("[CallKit-Swift] ‚ùå Error reporting call: \(error)")
+            } else {
+                print("[CallKit-Swift] ‚úÖ Call reported successfully")
             }
         })
     }

+    // ========== SILENCE AUDIO ANCHOR ==========
+    // This keeps the call active while waiting for TTS to load
+    // Without audio activity, iOS terminates the call after ~5-6 seconds
+    
+    private func startSilenceAnchor() {
+        print("[CallKit-Swift] üîá Starting silence audio anchor...")
+        
+        // Stop any existing silence player
+        stopSilenceAnchor()
+        
+        do {
+            let audioSession = AVAudioSession.sharedInstance()
+            // REMOVED .mixWithOthers - can cause conflicts with TTS
+            try audioSession.setCategory(.playAndRecord, mode: .voiceChat, options: [.defaultToSpeaker, .allowBluetooth])
+            try audioSession.setActive(true)
+            try audioSession.overrideOutputAudioPort(.speaker)
+            print("[CallKit-Swift] ‚úÖ Audio session configured for silence anchor (speaker forced)")
+        } catch {
+            print("[CallKit-Swift] ‚ö†Ô∏è Audio session error for silence: \(error)")
+        }
+        
+        // Try to use silence.caf if it exists
+        if let silenceURL = Bundle.main.url(forResource: "silence", withExtension: "caf") {
+            do {
+                silencePlayer = try AVAudioPlayer(contentsOf: silenceURL)
+                silencePlayer?.numberOfLoops = -1 // Loop indefinitely
+                silencePlayer?.volume = 0.01 // Nearly silent
+                silencePlayer?.prepareToPlay()
+                silencePlayer?.play()
+                print("[CallKit-Swift] ‚úÖ Silence anchor started (silence.caf)")
+                return
+            } catch {
+                print("[CallKit-Swift] ‚ö†Ô∏è Could not play silence.caf: \(error)")
+            }
+        }
+        
+        // Fallback: Generate minimal audio data programmatically
+        print("[CallKit-Swift] üìù Generating synthetic silence audio...")
+        generateAndPlaySyntheticSilence()
+    }
+    
+    private func generateAndPlaySyntheticSilence() {
+        // Create minimal PCM silence data (1 second of silence at 8000Hz mono)
+        let sampleRate: Double = 8000
+        let duration: Double = 1.0
+        let numSamples = Int(sampleRate * duration)
+        
+        // Create silent audio buffer
+        var silenceData = Data()
+        let silentSample: Int16 = 0
+        for _ in 0..<numSamples {
+            var sample = silentSample
+            silenceData.append(Data(bytes: &sample, count: 2))
+        }
+        
+        // Create WAV header
+        let wavData = createWAVData(pcmData: silenceData, sampleRate: Int(sampleRate))
+        
+        do {
+            silencePlayer = try AVAudioPlayer(data: wavData)
+            silencePlayer?.numberOfLoops = -1
+            silencePlayer?.volume = 0.01
+            silencePlayer?.prepareToPlay()
+            silencePlayer?.play()
+            print("[CallKit-Swift] ‚úÖ Synthetic silence anchor started")
+        } catch {
+            print("[CallKit-Swift] ‚ùå Could not play synthetic silence: \(error)")
+            // Last resort: use timer to periodically ping audio session
+            startSilenceTimer()
+        }
+    }
+    
+    private func createWAVData(pcmData: Data, sampleRate: Int) -> Data {
+        var wavData = Data()
+        
+        // RIFF header
+        wavData.append("RIFF".data(using: .ascii)!)
+        var fileSize = UInt32(36 + pcmData.count)
+        wavData.append(Data(bytes: &fileSize, count: 4))
+        wavData.append("WAVE".data(using: .ascii)!)
+        
+        // fmt chunk
+        wavData.append("fmt ".data(using: .ascii)!)
+        var fmtSize: UInt32 = 16
+        wavData.append(Data(bytes: &fmtSize, count: 4))
+        var audioFormat: UInt16 = 1 // PCM
+        wavData.append(Data(bytes: &audioFormat, count: 2))
+        var numChannels: UInt16 = 1 // Mono
+        wavData.append(Data(bytes: &numChannels, count: 2))
+        var sampleRateVal: UInt32 = UInt32(sampleRate)
+        wavData.append(Data(bytes: &sampleRateVal, count: 4))
+        var byteRate: UInt32 = UInt32(sampleRate * 2)
+        wavData.append(Data(bytes: &byteRate, count: 4))
+        var blockAlign: UInt16 = 2
+        wavData.append(Data(bytes: &blockAlign, count: 2))
+        var bitsPerSample: UInt16 = 16
+        wavData.append(Data(bytes: &bitsPerSample, count: 2))
+        
+        // data chunk
+        wavData.append("data".data(using: .ascii)!)
+        var dataSize = UInt32(pcmData.count)
+        wavData.append(Data(bytes: &dataSize, count: 4))
+        wavData.append(pcmData)
+        
+        return wavData
+    }
+    
+    private func startSilenceTimer() {
+        print("[CallKit-Swift] ‚è±Ô∏è Starting silence timer fallback...")
+        silenceTimer?.invalidate()
+        silenceTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
+            // Keep audio session active
+            do {
+                try AVAudioSession.sharedInstance().setActive(true)
+            } catch {}
+        }
+    }
+    
+    private func stopSilenceAnchor() {
+        print("[CallKit-Swift] üîá Stopping silence anchor...")
+        silencePlayer?.stop()
+        silencePlayer = nil
+        silenceTimer?.invalidate()
+        silenceTimer = nil
+    }
+    
+    // ========== END SILENCE AUDIO ANCHOR ==========

+    // REMOVED: Don't end call automatically
     public func endCall(uuid: UUID) {
         let controller = CXCallController()
         let transaction = CXTransaction(action: CXEndCallAction(call: uuid))
-        controller.request(transaction, completion: { error in })
+        controller.request(transaction, completion: { error in
+            if let error = error {
+                print("[CallKit-Swift] ‚ùå Error ending call: \(error)")
+            } else {
+                print("[CallKit-Swift] ‚úÖ Call ended successfully")
+            }
+        })
+        
+        // Cleanup
+        self.activeCallUUID = nil
+        self.connectionIdRegistry[uuid] = nil
+        self.stopAudio()
+        self.stopSilenceAnchor()
+    }
+    
+    // NEW: End call from JavaScript (after TTS finishes)
+    @objc func endCallFromJS(_ call: CAPPluginCall) {
+        print("[CallKit-Swift] üì± endCallFromJS called from JavaScript")
+        
+        guard let uuid = activeCallUUID else {
+            print("[CallKit-Swift] ‚ö†Ô∏è No active call to end")
+            call.resolve(["ended": false, "reason": "no_active_call"])
+            return
+        }
+        
+        print("[CallKit-Swift] üîö Ending call: \(uuid)")
+        endCall(uuid: uuid)
+        call.resolve(["ended": true])
+    }
+    
+    // NEW: Configure audio session for TTS during call
+    @objc func configureAudioSession(_ call: CAPPluginCall) {
+        print("[CallKit-Swift] üîä Configuring audio session for TTS")
+        
+        do {
+            let audioSession = AVAudioSession.sharedInstance()
+            
+            // Use playAndRecord to allow audio during call
+            try audioSession.setCategory(.playAndRecord, mode: .voiceChat, options: [.defaultToSpeaker, .allowBluetooth])
+            try audioSession.setActive(true)
+            // FORCE speaker output - .defaultToSpeaker alone doesn't guarantee speaker
+            try audioSession.overrideOutputAudioPort(.speaker)
+            
+            print("[CallKit-Swift] ‚úÖ Audio session configured (speaker forced)")
+            call.resolve(["configured": true])
+        } catch {
+            print("[CallKit-Swift] ‚ùå Audio session error: \(error)")
+            call.resolve(["configured": false, "error": error.localizedDescription])
+        }
+    }
+    
+    // NEW: Play TTS audio during call
+    @objc func playTTSAudio(_ call: CAPPluginCall) {
+        // 1Ô∏è‚É£ Log CHAMADA do m√©todo
+        print("[CallKit-Swift] üîä playTTSAudio CALLED")
+        notifyListeners("debug", data: [
+            "stage": "swift_playTTSAudio_called",
+            "timestamp": ISO8601DateFormatter().string(from: Date())
+        ])
+        
+        guard let base64Audio = call.getString("audio") else {
+            print("[CallKit-Swift] ‚ùå No audio data provided")
+            notifyListeners("debug", data: [
+                "stage": "tts_error",
+                "error": "no_audio_data"
+            ])
+            call.resolve(["playing": false, "error": "no_audio_data"])
+            return
+        }
+        
+        print("[CallKit-Swift] üéµ Base64 audio length: \(base64Audio.count)")
+        
+        // 6Ô∏è‚É£ Log se silencePlayer est√° tocando
+        let silenceIsPlaying = silencePlayer?.isPlaying ?? false
+        print("[CallKit-Swift] üîá Silence player isPlaying: \(silenceIsPlaying)")
+        notifyListeners("debug", data: [
+            "stage": "tts_silence_check",
+            "silencePlayerPlaying": silenceIsPlaying,
+            "base64Length": base64Audio.count
+        ])
+        
+        // Stop silence anchor when TTS starts
+        stopSilenceAnchor()
+        
+        guard let audioData = Data(base64Encoded: base64Audio) else {
+            print("[CallKit-Swift] ‚ùå Invalid base64 audio")
+            notifyListeners("debug", data: [
+                "stage": "tts_error",
+                "error": "invalid_base64"
+            ])
+            call.resolve(["playing": false, "error": "invalid_base64"])
+            return
+        }
+        
+        print("[CallKit-Swift] üì¶ Audio data decoded: \(audioData.count) bytes")
+        notifyListeners("debug", data: [
+            "stage": "swift_audio_decoded",
+            "audioBytes": audioData.count
+        ])
+        
+        do {
+            // üîá CLEANUP: Ensure previous players are completely stopped
+            audioPlayer?.stop()
+            audioPlayer = nil
+            stopSilenceAnchor()
+            
+            // ========== AUDIO SESSION FOR CALLKIT COMPATIBILITY ==========
+            // MUST use .playAndRecord during CallKit calls - .playback is IGNORED by iOS!
+            let audioSession = AVAudioSession.sharedInstance()
+            
+            // 1Ô∏è‚É£ FIRST: Configure audio session for CallKit (MUST use .playAndRecord)
+            try audioSession.setCategory(.playAndRecord, mode: .voiceChat, options: [.defaultToSpeaker, .allowBluetooth])
+            try audioSession.setActive(true)
+            try audioSession.overrideOutputAudioPort(.speaker)
+            
+            print("[CallKit-Swift] üîä Audio session: .playAndRecord + .voiceChat + speaker")
+            
+            // Log initial route
+            var route1 = audioSession.currentRoute
+            var port1 = route1.outputs.first?.portType.rawValue ?? "unknown"
+            print("[CallKit-Swift] üîà Route after 1st override: \(port1)")
+            
+            // 2Ô∏è‚É£ Force speaker using audioQueue for synchronization
+            self.audioQueue.sync {
+                do {
+                    try audioSession.overrideOutputAudioPort(.speaker)
+                    print("[CallKit-Swift] üîä audioQueue: speaker forced (sync)")
+                } catch {
+                    print("[CallKit-Swift] ‚ùå audioQueue: force speaker failed: \(error)")
+                }
+            }
+            
+            // Create audio player
+            audioPlayer = try AVAudioPlayer(data: audioData)
+            audioPlayer?.delegate = self
+            audioPlayer?.volume = 1.0
+            audioPlayer?.enableRate = false
+            audioPlayer?.prepareToPlay()
+            
+            // 3Ô∏è‚É£ THIRD override AFTER creating player (iOS can reset route)
+            try audioSession.overrideOutputAudioPort(.speaker)
+            
+            // Log route after creating player
+            route1 = audioSession.currentRoute
+            port1 = route1.outputs.first?.portType.rawValue ?? "unknown"
+            print("[CallKit-Swift] üîà Route after player creation + 3rd override: \(port1)")
+            
+            // 4Ô∏è‚É£ FOURTH override via audioQueue again
+            self.audioQueue.sync {
+                do {
+                    try audioSession.overrideOutputAudioPort(.speaker)
+                } catch {}
+            }
+            
+            // 5Ô∏è‚É£ Final route verification
+            let finalRoute = audioSession.currentRoute
+            let finalPort = finalRoute.outputs.first?.portType.rawValue ?? "unknown"
+            let finalName = finalRoute.outputs.first?.portName ?? "unknown"
+            
+            print("[CallKit-Swift] üîà FINAL audio route: \(finalPort) (\(finalName))")
+            for output in finalRoute.outputs {
+                print("[CallKit-Swift] üîà Output: \(output.portName) (\(output.portType.rawValue))")
+            }
+            
+            notifyListeners("debug", data: [
+                "stage": "audio_route_verification",
+                "outputPort": finalPort,
+                "outputName": finalName,
+                "isSpeaker": finalPort == "Speaker",
+                "overrideCount": 4,
+                "category": "playAndRecord",
+                "mode": "voiceChat"
+            ])
+            
+            // Log duration
+            let duration = audioPlayer?.duration ?? -1
+            print("[CallKit-Swift] ‚è±Ô∏è TTS audio duration: \(duration) seconds")
+            notifyListeners("debug", data: [
+                "stage": "tts_player_created",
+                "duration": duration
+            ])
+            
+            // üîä FORCE SYSTEM VOLUME TO MAXIMUM
+            let currentSystemVolume = audioSession.outputVolume
+            print("[CallKit-Swift] üì¢ System volume BEFORE: \(currentSystemVolume)")
+            notifyListeners("debug", data: [
+                "stage": "system_volume_before",
+                "volume": currentSystemVolume
+            ])
+            
+            // Use MPVolumeView to set system volume to maximum
+            DispatchQueue.main.async {
+                let volumeView = MPVolumeView()
+                if let slider = volumeView.subviews.first(where: { $0 is UISlider }) as? UISlider {
+                    print("[CallKit-Swift] üì¢ Found volume slider, setting to 1.0")
+                    slider.setValue(1.0, animated: false)
+                    print("[CallKit-Swift] üì¢ System volume FORCED to: 1.0")
+                } else {
+                    print("[CallKit-Swift] ‚ö†Ô∏è Could not find volume slider in MPVolumeView")
+                }
+            }
+            
+            // Small delay to ensure volume is set before playing
+            Thread.sleep(forTimeInterval: 0.1)
+            
+            // PLAY TTS
+            let didPlay = audioPlayer?.play() ?? false
+            print("[CallKit-Swift] ‚ñ∂Ô∏è TTS play() returned: \(didPlay)")
+            
+            // 6Ô∏è‚É£ DELAYED OVERRIDE: Force speaker AFTER playback starts
+            // This catches any CallKit resets that happen during play() initialization
+            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
+                do {
+                    let session = AVAudioSession.sharedInstance()
+                    try session.overrideOutputAudioPort(.speaker)
+                    let delayedRoute = session.currentRoute
+                    let delayedPort = delayedRoute.outputs.first?.portType.rawValue ?? "unknown"
+                    print("[CallKit-Swift] üîä DELAYED speaker override (300ms): \(delayedPort)")
+                    
+                    self?.notifyListeners("debug", data: [
+                        "stage": "tts_delayed_override",
+                        "outputPort": delayedPort,
+                        "isSpeaker": delayedPort == "Speaker"
+                    ])
+                } catch {
+                    print("[CallKit-Swift] ‚ùå Delayed override failed: \(error)")
+                }
+            }
+            
+            // Final summary
+            print("[CallKit-Swift] ====== TTS PLAYBACK SUMMARY ======")
+            print("[CallKit-Swift] playTTSAudio CALLED: ‚úÖ")
+            print("[CallKit-Swift] play() returned: \(didPlay)")
+            print("[CallKit-Swift] audio route: \(finalPort)")
+            print("[CallKit-Swift] isSpeaker: \(finalPort == "Speaker")")
+            print("[CallKit-Swift] duration: \(duration)s")
+            print("[CallKit-Swift] systemVolume: \(currentSystemVolume)")
+            print("[CallKit-Swift] playerVolume: \(audioPlayer?.volume ?? -1)")
+            print("[CallKit-Swift] ===================================")
+            
+            notifyListeners("debug", data: [
+                "stage": "swift_play_result",
+                "didPlay": didPlay,
+                "duration": duration,
+                "playerVolume": audioPlayer?.volume ?? -1,
+                "systemVolume": currentSystemVolume,
+                "outputPort": finalPort,
+                "isSpeaker": finalPort == "Speaker"
+            ])
+            
+            call.resolve(["playing": didPlay, "duration": duration])
+        } catch {
+            print("[CallKit-Swift] ‚ùå Audio playback error: \(error.localizedDescription)")
+            notifyListeners("debug", data: [
+                "stage": "tts_play_error",
+                "error": error.localizedDescription
+            ])
+            call.resolve(["playing": false, "error": error.localizedDescription])
+        }
+    }
+    
+    // 5Ô∏è‚É£ Audio player delegate - capture decode errors
+    public func audioPlayerDecodeErrorDidOccur(_ player: AVAudioPlayer, error: Error?) {
+        print("[CallKit-Swift] ‚ùå Audio decode error: \(error?.localizedDescription ?? "nil")")
+        notifyListeners("debug", data: [
+            "stage": "tts_decode_error",
+            "error": error?.localizedDescription ?? "nil"
+        ])
+    }
+    
+    public func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
+        print("[CallKit-Swift] ‚úÖ Audio finished playing, success: \(flag)")
+        notifyListeners("debug", data: [
+            "stage": "tts_finished",
+            "success": flag
+        ])
+    }
+    
+    // NEW: Stop TTS audio
+    @objc func stopTTSAudio(_ call: CAPPluginCall) {
+        print("[CallKit-Swift] üîá Stopping TTS audio")
+        stopAudio()
+        call.resolve(["stopped": true])
+    }
+    
+    private func stopAudio() {
+        audioPlayer?.stop()
+        audioPlayer = nil
     }
 }


 // MARK: CallKit events handler

 extension CallKitVoipPlugin: CXProviderDelegate {

     public func providerDidReset(_ provider: CXProvider) {
-        print("providerDidReset")
+        print("[CallKit-Swift] Provider reset")
+        activeCallUUID = nil
+        connectionIdRegistry.removeAll()
+        stopAudio()
+        stopSilenceAnchor()
     }

     public func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {
-        print("CXAnswerCallAction answers an incoming call")
+        // User answered the call
+        print("[CallKit-Swift] ====== CALL ANSWERED ======")
+        print("[CallKit-Swift] UUID: \(action.callUUID)")
+        
+        // ‚úÖ CRITICAL: Start silence anchor IMMEDIATELY
+        // This keeps the call active while waiting for TTS to load
+        startSilenceAnchor()
+        
+        // Notify JavaScript that call was answered
         notifyEvent(eventName: "callAnswered", uuid: action.callUUID)
-        endCall(uuid: action.callUUID)
+        
+        // ‚úÖ IMPORTANT: DO NOT call endCall() here!
+        // The call stays active so TTS can play on the native screen.
+        // JavaScript will call endCallFromJS() after TTS finishes.
+        
         action.fulfill()
     }

     public func provider(_ provider: CXProvider, perform action: CXEndCallAction) {
-        print("CXEndCallAction end an incoming call")
+        // Call ended (either by user or by endCallFromJS)
+        print("[CallKit-Swift] ====== CALL ENDED ======")
         notifyEvent(eventName: "callEnded", uuid: action.callUUID)
+        
+        // Cleanup
+        connectionIdRegistry[action.callUUID] = nil
+        if activeCallUUID == action.callUUID {
+            activeCallUUID = nil
+        }
+        stopAudio()
+        stopSilenceAnchor()
+        
         action.fulfill()
     }

     public func provider(_ provider: CXProvider, perform action: CXStartCallAction) {
-        print("CXStartCallAction end an outgoing call")
+        // Outgoing call started
+        print("[CallKit-Swift] ====== CALL STARTED ======")
         notifyEvent(eventName: "callStarted", uuid: action.callUUID)
         action.fulfill()
     }
+    
+    // Handle audio session activation - CRITICAL for speaker and keeping call alive
+    public func provider(_ provider: CXProvider, didActivate audioSession: AVAudioSession) {
+        print("[CallKit-Swift] üîä Audio session activated by CallKit - FORCING SPEAKER")
+        
+        // üîä FORCE SPEAKER IMMEDIATELY when CallKit activates audio session
+        // This is the CORRECT moment to configure audio - CallKit has given us control
+        do {
+            try audioSession.setCategory(.playAndRecord, mode: .voiceChat, options: [.defaultToSpeaker, .allowBluetooth])
+            try audioSession.overrideOutputAudioPort(.speaker)
+            
+            let route = audioSession.currentRoute
+            let port = route.outputs.first?.portType.rawValue ?? "unknown"
+            print("[CallKit-Swift] ‚úÖ Speaker forced in didActivate: \(port)")
+            
+            notifyListeners("debug", data: [
+                "stage": "didActivate_speaker_forced",
+                "outputPort": port,
+                "isSpeaker": port == "Speaker"
+            ])
+        } catch {
+            print("[CallKit-Swift] ‚ùå Failed to force speaker in didActivate: \(error)")
+        }
+        
+        // Start silence anchor here as backup
+        if silencePlayer == nil {
+            startSilenceAnchor()
+        }
+    }
+    
+    public func provider(_ provider: CXProvider, didDeactivate audioSession: AVAudioSession) {
+        print("[CallKit-Swift] üîá Audio session deactivated")
+        stopAudio()
+        stopSilenceAnchor()
+    }
 }

 // MARK: PushKit events handler
 extension CallKitVoipPlugin: PKPushRegistryDelegate {

     public func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
         let parts = pushCredentials.token.map { String(format: "%02.2hhx", $0) }
         let token = parts.joined()
-        print("VOIP didUpdate pushCredentials: \(token)")
+        print("[CallKit-Swift] üì≤ VoIP Token: \(token.prefix(20))...")
         notifyListeners("registration", data: ["value": token])
     }

     public func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {
-        print("didReceiveIncomingPushWith: \(type.rawValue)")
-        print("didReceiveIncomingPushWith payload: \(payload.dictionaryPayload)")
+        print("[CallKit-Swift] ====== VOIP PUSH RECEIVED ======")
+        
         guard let id = payload.dictionaryPayload["id"] as? String else {
-            print("id required")
+            print("[CallKit-Swift] ‚ùå Missing 'id' in payload")
             completion()
             return
         }
+        
         let media = (payload.dictionaryPayload["media"] as? String) ?? "voice"
         let name = (payload.dictionaryPayload["name"] as? String) ?? "Evento"
         let duration = (payload.dictionaryPayload["duration"] as? String) ?? "0"
+        
+        // Extract language for TTS (sent from check-upcoming-alerts)
+        let language = (payload.dictionaryPayload["language"] as? String) ?? "pt-BR"
+        let eventTime = (payload.dictionaryPayload["eventTime"] as? String) ?? duration
+        let eventEmoji = (payload.dictionaryPayload["eventEmoji"] as? String) ?? "calendario"
+        let eventLocation = (payload.dictionaryPayload["eventLocation"] as? String) ?? ""
+        
+        print("[CallKit-Swift] id: \(id)")
+        print("[CallKit-Swift] name: \(name)")
+        print("[CallKit-Swift] media: \(media)")
+        print("[CallKit-Swift] duration: \(duration)")
+        print("[CallKit-Swift] language: \(language)")
+        print("[CallKit-Swift] eventTime: \(eventTime)")
+        
+        // Notify JavaScript about the incoming push (for TTS pre-loading)
+        notifyListeners("callStarted", data: [
+            "eventId": id,
+            "eventTitle": name,
+            "eventTime": eventTime,
+            "eventEmoji": eventEmoji,
+            "eventLocation": eventLocation,
+            "language": language,
+        ])
+        
         self.incomingCall(id: id, media: media, name: name, duration: duration)
         completion()
     }
 }

 extension CallKitVoipPlugin {
     struct CallConfig {
         let id: String
         let media: String
         let name: String
         let duration: String
     }
 }
